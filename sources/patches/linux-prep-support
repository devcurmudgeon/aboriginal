First cut at PReP support for arch/powerpc

Here is an implementation to allow PReP systems to boot under the
arch/powerpc codebase, one of the few remaining platforms supported in
arch/ppc but not so far in arch/powerpc.

This support is still fairly incomplete - it needs to obtain a lot
more device information from the residual data and put it into the
device tree, rather than relying on hardcoded values (both in the code
and in prep.dts).  Likewise many peripherals will not be supported -
in particular the RTC is not yet supported, so the time will generally
be wrong.

Still, it should do enough to boot on a number of PReP machines, and
makes a reasonable start.

Signed-off-by: David Gibson <david@gibson.dropbear.id.au>

Index: working-2.6/arch/powerpc/Kconfig.debug
===================================================================
--- working-2.6.orig/arch/powerpc/Kconfig.debug	2007-08-06 13:48:10.000000000 +1000
+++ working-2.6/arch/powerpc/Kconfig.debug	2007-08-06 14:01:48.000000000 +1000
@@ -211,6 +211,13 @@ config PPC_EARLY_DEBUG_44x
 	  Select this to enable early debugging for IBM 44x chips via the
 	  inbuilt serial port.
 
+config PPC_EARLY_DEBUG_PREP
+	bool "PReP serial port"
+	depends on PPC_PREP
+	help
+	  Select this to enable early debugging for PReP, assuming an
+	  8250-style serial port at address 0x800003f8.
+
 endchoice
 
 config PPC_EARLY_DEBUG_44x_PHYSLOW
Index: working-2.6/arch/powerpc/boot/Makefile
===================================================================
--- working-2.6.orig/arch/powerpc/boot/Makefile	2007-08-06 14:01:48.000000000 +1000
+++ working-2.6/arch/powerpc/boot/Makefile	2007-08-06 14:01:48.000000000 +1000
@@ -48,7 +48,7 @@ src-wlib := string.S crt0.S stdio.c main
 		44x.c ebony.c mv64x60.c mpsc.c mv64x60_i2c.c cuboot.c
 src-plat := of.c cuboot-83xx.c cuboot-85xx.c holly.c \
 		cuboot-ebony.c treeboot-ebony.c prpmc2800.c \
-		ps3-head.S ps3-hvcall.S ps3.c
+		ps3-head.S ps3-hvcall.S ps3.c prep.c
 src-boot := $(src-wlib) $(src-plat) empty.c
 
 src-boot := $(addprefix $(obj)/, $(src-boot))
@@ -100,14 +100,14 @@ $(patsubst %.S,%.o, $(filter %.S, $(src-
 $(obj)/wrapper.a: $(obj-wlib) FORCE
 	$(call if_changed,bootar)
 
-hostprogs-y	:= addnote addRamDisk hack-coff mktree
+hostprogs-y	:= addnote addRamDisk hack-coff mktree mkprep
 
 targets		+= $(patsubst $(obj)/%,%,$(obj-boot) wrapper.a)
 extra-y		:= $(obj)/wrapper.a $(obj-plat) $(obj)/empty.o \
 		   $(obj)/zImage.lds $(obj)/zImage.coff.lds $(obj)/zImage.ps3.lds
 
 wrapper		:=$(srctree)/$(src)/wrapper
-wrapperbits	:= $(extra-y) $(addprefix $(obj)/,addnote hack-coff mktree) \
+wrapperbits	:= $(extra-y) $(addprefix $(obj)/,addnote hack-coff mktree mkprep) \
 			$(wrapper) FORCE
 
 #############
@@ -137,6 +137,7 @@ image-$(CONFIG_PPC_PMAC)		+= zImage.pmac
 image-$(CONFIG_PPC_HOLLY)		+= zImage.holly
 image-$(CONFIG_PPC_PRPMC2800)		+= zImage.prpmc2800
 image-$(CONFIG_PPC_ISERIES)		+= zImage.iseries
+image-$(CONFIG_PPC_PREP)		+= zImage.dts.prep
 image-$(CONFIG_DEFAULT_UIMAGE)		+= uImage
 
 ifneq ($(CONFIG_DEVICE_TREE),"")
Index: working-2.6/arch/powerpc/boot/dts/prep.dts
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/boot/dts/prep.dts	2007-08-06 14:02:13.000000000 +1000
@@ -0,0 +1,129 @@
+/*
+ * PReP skeleton device tree
+ *
+ * Paul Mackerras <paulus@samba.org>
+ */
+
+/ {
+	device_type = "prep";
+	model = "IBM,PReP";
+	compatible = "prep";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0>;
+			clock-frequency = <0>; // filled in by bootwrapper
+			bus-frequency = <0>; // filled in by bootwrapper
+			timebase-frequency = <0>; // filled in by bootwrapper
+			i-cache-line-size = <0>; // filled in by bootwrapper
+			d-cache-line-size = <0>; // filled in by bootwrapper
+			d-cache-size = <0>; // filled in by bootwrapper
+			i-cache-size = <0>; // filled in by bootwrapper
+
+			l2-cache {
+				device_type = "cache";
+				i-cache-size = <00100000>;
+				d-cache-size = <00100000>;
+				i-cache-sets = <00008000>;
+				d-cache-sets = <00008000>;
+				i-cache-line-size = <00000020>;
+				d-cache-line-size = <00000020>;
+				cache-unified;
+			};
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		// dummy range here, zImage wrapper will fill in the actual
+		// amount of memory from the residual data
+		reg = <00000000 00000000>;
+	};
+
+	pci@80000000 {
+		device_type = "pci";
+		compatible = "prep-pci";
+		clock-frequency = <01fca055>;
+		reg = <80000000 7effffff>;
+		8259-interrupt-acknowledge = <bffffff0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+		ranges=<01000000 00000000 00000000 80000000 00000000 00800000
+			01000000 00000000 00800000 81000000 00000000 3e800000
+			02000000 00000000 00000000 c0000000 00000000 01000000
+			02000000 00000000 01000000 c1000000 00000000 3e000000>;
+		interrupt-map-mask = <f800 0 0 7>;
+		interrupt-map = <6000 0 0 1	&MPIC 6 0
+				 8000 0 0 1	&MPIC 7 0
+				 9000 0 0 1	&MPIC 2 0
+				 b000 0 0 1	&MPIC 1 0>;
+
+		isa {
+			device_type = "isa";
+			#address-cells = <2>;
+			#size-cells = <1>;
+			#interrupt-cells = <2>;
+			ranges = <00000001 00000000
+				  01005800 00000000 00000000  00010000
+				  00000000 00000000
+				  02005800 00000000 00000000  01000000>;
+
+			parallel {
+				device_type = "parallel";
+				compatible = "pnpPNP,401", "pnpPNP,400";
+				reg =  <00000001 000003bc  00000008
+					00000001 000007bc  00000006>;
+				interrupts = <00000007 00000003>;
+				interrupt-parent = <&PIC8259>;
+			};
+
+			serial@3f8 {
+				device_type = "serial";
+				compatible = "pnpPNP,501", "pnpPNP,500";
+				clock-frequency = <001c2000>;
+				reg =  <00000001 000003f8  00000008>;
+				interrupts = <00000004 00000003>;
+				interrupt-parent = <&PIC8259>;
+			};
+			serial@2f8 {
+				device_type = "serial";
+				compatible = "pnpPNP,501";
+				clock-frequency = <001c2000>;
+				reg =  <00000001 000002f8  00000008>;
+				interrupts = <00000003 00000003>;
+				interrupt-parent = <&PIC8259>;
+			};
+			PIC8259: interrupt-controller {
+				device_type = "i8259";
+				compatible = "prep,iic";
+				interrupt-controller;
+				reg = <	00000001 00000020  00000002
+					00000001 000000a0  00000002
+					00000001 000004d0  00000002>;
+				interrupts = <00000000 00000003
+					      00000002 00000003>;
+				interrupt-parent = <&MPIC>;
+			};
+		};
+
+		MPIC: interrupt-controller@d {
+			device_type = "open-pic";
+			compatible = "mpic";
+			interrupt-controller;
+			reg = <	00006800 00000000 00000000  00000000 00000000
+				02006810 00000000 00000000  00000000 00040000>;
+			assigned-addresses = <
+				82006810 00000000 3afc0000  00000000 00040000>;
+		};
+	};
+
+	chosen {
+		linux,stdout-path = "/pci/isa/serial@3f8";
+	};
+};
Index: working-2.6/arch/powerpc/boot/mkprep.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/boot/mkprep.c	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,178 @@
+/*
+ * Makes a prep bootable image which can be dd-ed onto a disk device
+ * to make a bootdisk.  Will take as input an ELF executable, strip
+ * off the header and write out a boot image.
+ *
+ * Modified for x86 hosted builds by Matt Porter <porter@neta.com>
+ * Modified for Sparc hosted builds by Peter Wahl <PeterWahl@web.de>
+ *
+ * Largely rewritten by David Gibson <david@gibson.dropbear.id.au>
+ * Copyright (C) 2007 IBM Corporation.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <endian.h>
+#include <byteswap.h>
+#include <elf.h>
+#include <errno.h>
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define cpu_to_le16(x)		(x)
+#define cpu_to_le32(x)		(x)
+#define be16_to_cpu(x)		(bswap_16(x))
+#define be32_to_cpu(x)		(bswap_32(x))
+#else
+#define cpu_to_le16(x)		(bswap_16(x))
+#define cpu_to_le32(x)		(bswap_32(x))
+#define be16_to_cpu(x)		(x)
+#define be32_to_cpu(x)		(x)
+#endif
+
+/* The PReP image header resembles a DOS-style floppy disk boot sector
+ * including a partition table with a type 0x41 partition */
+struct prep_header {
+	uint32_t entry1, length1;
+
+	uint8_t _pad0[438];
+
+	/* Partition table entry  - offset 0x1be*/
+	uint8_t active;
+	uint8_t start_head, start_sector, start_cylinder;
+	uint8_t partition_type;
+	uint8_t end_head, end_sector, end_cylinder;
+	uint32_t beginning_sector;
+	uint32_t number_of_sectors;
+
+	uint8_t _pad1[48];
+
+	/* DOS boot sector magic number - offset 510 */
+	uint16_t magic;
+
+	/* For some reason the header has 2 copies of the entry point
+	 * and length  - offset 512*/
+	uint32_t entry2, length2;
+
+	uint8_t _pad2[504];
+} __attribute__((packed));
+
+#define PREP_HEADER_SIZE	sizeof(struct prep_header)
+#define DOS_PARTITION_MAGIC	(cpu_to_le16(0xaa55))
+
+struct image_info {
+	unsigned int size;
+	unsigned int entryoffset;
+};
+
+static void die(const char *str, ...)
+{
+        va_list ap;
+
+        va_start(ap, str);
+        vfprintf(stderr, str, ap);
+        exit(1);
+}
+
+static void parse_image(FILE *in, struct image_info *ii)
+{
+	char elfheader[256];
+	Elf32_Ehdr *elf32 = (Elf32_Ehdr *)elfheader;
+	Elf32_Phdr *elf32ph;
+	unsigned int i;
+
+	if (fread(elfheader, sizeof(elfheader), 1, in) != 1)
+		die("Unable to read image's ELF header\n");
+
+	if (!(elf32->e_ident[EI_MAG0]  == ELFMAG0	&&
+	      elf32->e_ident[EI_MAG1]  == ELFMAG1	&&
+	      elf32->e_ident[EI_MAG2]  == ELFMAG2	&&
+	      elf32->e_ident[EI_MAG3]  == ELFMAG3	&&
+	      elf32->e_ident[EI_CLASS] == ELFCLASS32	&&
+	      elf32->e_ident[EI_DATA]  == ELFDATA2MSB	&&
+	      be16_to_cpu(elf32->e_type) == ET_EXEC	&&
+	      be16_to_cpu(elf32->e_machine) == EM_PPC))
+		die("Input doesn't appear to be a PowerPC ELF image\n");
+
+	elf32ph = (Elf32_Phdr *) (elfheader + elf32->e_phoff);
+	for (i = 0; i < elf32->e_phnum; i++, elf32ph++)
+		if (be32_to_cpu(elf32ph->p_type) == PT_LOAD)
+			break;
+	if (i >= be16_to_cpu(elf32->e_phnum))
+		die("Couldn't find image's PT_LOAD program header\n");
+
+	ii->size = be32_to_cpu(elf32ph->p_filesz);
+	ii->entryoffset = be32_to_cpu(elf32->e_entry)
+		- be32_to_cpu(elf32ph->p_vaddr);
+
+	/* skip elf header in input file */
+	fseek(in, be32_to_cpu(elf32ph->p_offset), SEEK_SET);
+}
+
+static void write_prep_header(FILE *out, const struct image_info *ii)
+{
+	struct prep_header hdr = {
+		/*
+		 * The first block of the diskette is used by this
+		 * "boot record" which actually contains the partition
+		 * table. (The first block of the partition contains
+		 * the boot image, but I digress...)  We'll set up one
+		 * partition on the diskette and it shall contain the
+		 * rest of the diskette.
+		 */
+		.active = 0x80, 	/* partition bootable flag */
+		.start_head = 0,	/* zero-based */
+		.start_sector = 2,	/* one-based */
+		.start_cylinder = 0,	/* zero-based */
+		.partition_type = 0x41, /* PReP boot partition type */
+		.end_head = 1,		/* assumes two heads */
+		.end_sector = 18,	/* assumes 18 sectors/track */
+		.end_cylinder = 79,	/* assumes 80 cylinders/diskette */
+		/*
+		 * The "PReP" software ignores the above fields and
+		 * just looks at the next two.
+		 */
+		.beginning_sector = cpu_to_le32(0), /* Has to be 0 on the PowerStack? */
+		.number_of_sectors = cpu_to_le32(2*18*80-1),
+
+		.magic = DOS_PARTITION_MAGIC,
+	};
+
+	hdr.entry1 = hdr.entry2 = cpu_to_le32(PREP_HEADER_SIZE + ii->entryoffset);
+	hdr.length1 = hdr.length2 = cpu_to_le32(ii->size + PREP_HEADER_SIZE);
+
+	fwrite(&hdr, PREP_HEADER_SIZE, 1, out);
+}
+
+int main(int argc, char *argv[])
+{
+	FILE *in, *out;
+	char buf[0x1000];
+	int n;
+	struct image_info ii;
+
+	if (argc != 3)
+		die("usage: %s <input image (ELF)> <output image>\n", argv[0]);
+
+	if (strcmp(argv[1], "-") == 0)
+		in = stdin;
+	else if (!(in = fopen(argv[1], "r")))
+		die("Couldn't open input %s: %s\n", argv[1], strerror(errno));
+
+	if (strcmp(argv[2], "-") == 0)
+		out = stdout;
+	else if (!(out = fopen(argv[2], "w")))
+		exit(1);
+
+	parse_image(in, &ii);
+	write_prep_header(out, &ii);
+
+	/* write input image to bootimage */
+	while ( (n = fread(buf, 1, sizeof(buf), in)) > 0 )
+		fwrite(buf, 1, n, out);
+
+	exit(0);
+}
Index: working-2.6/arch/powerpc/boot/prep.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/boot/prep.c	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,150 @@
+/*
+ * PReP-specific stuff for the zImage boot wrapper.
+ *
+ * Copyright (C) 2006 Paul Mackerras, IBM Corp. <paulus@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License.
+ */
+#include <stddef.h>
+#include "string.h"
+#include "stdio.h"
+#include "of.h"
+#include "ops.h"
+#include "page.h"
+#include "residual.h"
+
+extern char _end[];
+extern char _dtb_start[], _dtb_end[];
+
+static RESIDUAL *residual_data;
+
+static unsigned long claim_base;
+
+#define	ONE_MB		0x100000
+
+static void *of_claim_malloc(unsigned long size)
+{
+	unsigned long addr = 0;
+	u32 xsize = size + sizeof(size);
+
+	/* Make space to store the block's size */
+	size = size + sizeof(size);
+
+	if (! claim_base)
+		/* First call, initialize claim_base */
+		claim_base = _ALIGN_UP((unsigned long)_end, ONE_MB);
+
+	for(; claim_base < residual_data->GoodMemory; claim_base += ONE_MB) {
+#ifdef DEBUG
+		printf("    trying: 0x%08lx\n\r", claim_base);
+#endif
+		addr = (unsigned long)of_claim(claim_base, xsize, 0);
+		if ((void *)addr != (void *)-1)
+			break;
+	}
+	if (addr == 0)
+		return NULL;
+	claim_base = PAGE_ALIGN(claim_base + xsize);
+	/* store the block's size */
+	*((u32 *)addr) = size;
+	return (void *)(addr + sizeof(size));
+}
+
+static void *of_claim_realloc(void *ptr, unsigned long size)
+{
+	u32 oldsize = 0;
+	void *new;
+
+	if (ptr)
+		oldsize = *((u32 *)(ptr - sizeof(u32)));
+	if (size <= oldsize)
+		return ptr;
+
+	new = of_claim_malloc(size);
+	if (! new)
+		return NULL;
+
+	memcpy(new + sizeof(u32), ptr + sizeof(u32), oldsize);
+	return new;
+}
+
+extern unsigned int __div64_32(unsigned long long *dividend,
+			       unsigned int divisor);
+
+static void prep_fixup_cpu(void *cpu)
+{
+	VPD *vpd = &residual_data->VitalProductData;
+
+	printf("PReP: I-Cache size <- 0x%lx\n\r", vpd->I_CacheSize * 1024);
+	setprop_val(cpu, "i-cache-size", vpd->I_CacheSize * 1024);
+	printf("PReP: D-Cache size <- 0x%lx\n\r", vpd->D_CacheSize * 1024);
+	setprop_val(cpu, "d-cache-size", vpd->D_CacheSize * 1024);
+
+	printf("PReP: I-Cache line size <- 0x%lx\n\r", vpd->I_CacheLineSize);
+	setprop_val(cpu, "i-cache-line-size", vpd->I_CacheLineSize);
+	printf("PReP: D-Cache line size <- 0x%lx\n\r", vpd->D_CacheLineSize);
+	setprop_val(cpu, "d-cache-line-size", vpd->D_CacheLineSize);
+}
+
+static void prep_fixups(void)
+{
+	VPD *vpd = &residual_data->VitalProductData;
+	void *devp;
+	u64 tb;
+	int ret;
+
+	if (!residual_data)
+		/* FIXME: we should be able to cope, somehow, without residual data */
+		fatal("PReP: no residual data\n\r");
+
+	/* Store a copy of residual data in the flat device tree */
+	devp = finddevice("/chosen");
+	if (! devp)
+		fatal("Couldn't find /chosen in device tree\n\r");
+
+	printf("PReP: %ld bytes of residual data\n\r",
+	       residual_data->ResidualLength);
+	ret = setprop(devp, "linux,prep-residual-data",
+		      residual_data, residual_data->ResidualLength);
+	if (ret != 0)
+		printf("Couldn't set linux,prep-residual-data property\n\r");
+
+	printf("PReP: TotalMemory = 0x%lx, GoodMemory = 0x%lx\n\r",
+	       residual_data->TotalMemory, residual_data->GoodMemory);
+	/* FIXME: This makes assumptions about the layout of the
+	 * memory devp(s) in the supplied flat tree, and the
+	 * address-cells / size-cells values. Should check or enforce
+	 * those assumptions */
+	dt_fixup_memory(0, residual_data->GoodMemory);
+
+	tb = (u64)vpd->ProcessorBusHz * 1000ULL;
+	__div64_32(&tb, vpd->TimeBaseDivisor);
+	dt_fixup_cpu_clocks(vpd->ProcessorHz, (u32)tb, vpd->ProcessorBusHz);
+
+	devp = NULL;
+	while ((devp = find_node_by_devtype(devp, "cpu")))
+		prep_fixup_cpu(devp);
+}
+
+void platform_init(unsigned long r3, unsigned long r4, void *promptr)
+{
+	if (r3)
+		if (((RESIDUAL *)r3)->ResidualLength)
+			residual_data = (void *)r3;
+	if (promptr) {
+		/* If we have OF, use it for console I/O */
+		of_init(promptr);
+		of_console_init();
+		platform_ops.malloc = of_claim_malloc;
+		platform_ops.realloc = of_claim_realloc;
+		platform_ops.exit = of_exit;
+		platform_ops.vmlinux_alloc = of_vmlinux_alloc;
+	} else {
+		/* look for a serial console */
+		/* XXX implement me */
+	}
+
+	platform_ops.fixups = prep_fixups;
+	ft_init(_dtb_start, _dtb_end - _dtb_start, 32);
+}
Index: working-2.6/arch/powerpc/boot/wrapper
===================================================================
--- working-2.6.orig/arch/powerpc/boot/wrapper	2007-08-06 13:48:10.000000000 +1000
+++ working-2.6/arch/powerpc/boot/wrapper	2007-08-06 14:01:48.000000000 +1000
@@ -233,6 +233,13 @@ coff)
     ${CROSS}objcopy -O aixcoff-rs6000 --set-start "$entry" "$ofile"
     $object/hack-coff "$ofile"
     ;;
+prep)
+    mv "$ofile" "$ofile".elf
+    $object/mkprep "$ofile".elf "$ofile"
+    if [ -z "$cacheit" ]; then
+	rm -f "$ofile.elf"
+    fi
+    ;;
 cuboot*)
     mv "$ofile" "$ofile".elf
     ${CROSS}objcopy -O binary "$ofile".elf "$ofile".bin
Index: working-2.6/arch/powerpc/kernel/misc_32.S
===================================================================
--- working-2.6.orig/arch/powerpc/kernel/misc_32.S	2007-08-06 14:01:47.000000000 +1000
+++ working-2.6/arch/powerpc/kernel/misc_32.S	2007-08-06 14:01:48.000000000 +1000
@@ -884,3 +884,30 @@ relocate_new_kernel_end:
 relocate_new_kernel_size:
 	.long relocate_new_kernel_end - relocate_new_kernel
 #endif
+
+/*
+ * These routines turn on the MMU temporarily to do an I/O access.
+ */
+_GLOBAL(virt_readb)
+	mfmsr	r6
+	ori	r7,r6,MSR_DR
+	sync
+	mtmsr	r7
+	isync
+	lbz	r3,0(r3)
+	sync
+	mtmsr	r6
+	isync
+	blr
+
+_GLOBAL(virt_writeb)
+	mfmsr	r6
+	ori	r7,r6,MSR_DR
+	sync
+	mtmsr	r7
+	isync
+	stb	r3,0(r4)
+	sync
+	mtmsr	r6
+	isync
+	blr
Index: working-2.6/arch/powerpc/kernel/setup_32.c
===================================================================
--- working-2.6.orig/arch/powerpc/kernel/setup_32.c	2007-08-06 13:48:11.000000000 +1000
+++ working-2.6/arch/powerpc/kernel/setup_32.c	2007-08-06 14:01:48.000000000 +1000
@@ -18,7 +18,6 @@
 #include <linux/cpu.h>
 #include <linux/console.h>
 
-#include <asm/residual.h>
 #include <asm/io.h>
 #include <asm/prom.h>
 #include <asm/processor.h>
Index: working-2.6/arch/powerpc/kernel/udbg_16550.c
===================================================================
--- working-2.6.orig/arch/powerpc/kernel/udbg_16550.c	2007-08-06 13:48:11.000000000 +1000
+++ working-2.6/arch/powerpc/kernel/udbg_16550.c	2007-08-06 14:01:48.000000000 +1000
@@ -11,6 +11,7 @@
 #include <linux/types.h>
 #include <asm/udbg.h>
 #include <asm/io.h>
+#include <asm/reg.h>
 
 extern u8 real_readb(volatile u8 __iomem  *addr);
 extern void real_writeb(u8 data, volatile u8 __iomem *addr);
@@ -214,3 +215,30 @@ void __init udbg_init_44x_as1(void)
 	udbg_putc = udbg_44x_as1_putc;
 }
 #endif /* CONFIG_PPC_EARLY_DEBUG_44x */
+
+#ifdef CONFIG_PPC_PREP
+extern u8 virt_readb(volatile u8 __iomem  *addr);
+extern void virt_writeb(u8 data, volatile u8 __iomem *addr);
+
+void udbg_prep_putc(char c)
+{
+	if (udbg_comport) {
+		while ((virt_readb(&udbg_comport->lsr) & LSR_THRE) == 0)
+			/* wait for idle */;
+		virt_writeb(c, &udbg_comport->thr);
+		if (c == '\n')
+			udbg_prep_putc('\r');
+	}
+}
+
+void udbg_init_prep(void)
+{
+	/* setup DBAT3 to map I/O */
+	mtspr(SPRN_DBAT3U, 0x80001ffe);
+	mtspr(SPRN_DBAT3L, 0x8000002a);
+	udbg_comport = (volatile struct NS16550 __iomem *) 0x800003f8;
+	udbg_putc = udbg_prep_putc;
+	udbg_getc = NULL;
+	udbg_getc_poll = NULL;
+}
+#endif /* CONFIG_PPC_PREP */
Index: working-2.6/arch/powerpc/platforms/prep/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/platforms/prep/Makefile	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,4 @@
+obj-y			+= setup.o
+#obj-$(CONFIG_PCI)	+= pci.o
+#obj-$(CONFIG_NVRAM)	+= nvram.o
+
Index: working-2.6/arch/powerpc/platforms/prep/nvram.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/platforms/prep/nvram.c	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 1998  Corey Minyard
+ *
+ * This reads the NvRAM on PReP compliant machines (generally from IBM or
+ * Motorola).  Motorola kept the format of NvRAM in their ROM, PPCBUG, the
+ * same, long after they had stopped producing PReP compliant machines.  So
+ * this code is useful in those cases as well.
+ *
+ */
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+
+#include <asm/sections.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/prep_nvram.h>
+
+static char nvramData[MAX_PREP_NVRAM];
+static NVRAM_MAP *nvram=(NVRAM_MAP *)&nvramData[0];
+
+unsigned char prep_nvram_read_val(int addr)
+{
+	outb(addr, PREP_NVRAM_AS0);
+	outb(addr>>8, PREP_NVRAM_AS1);
+	return inb(PREP_NVRAM_DATA);
+}
+
+void prep_nvram_write_val(int           addr,
+			  unsigned char val)
+{
+	outb(addr, PREP_NVRAM_AS0);
+	outb(addr>>8, PREP_NVRAM_AS1);
+   	outb(val, PREP_NVRAM_DATA);
+}
+
+void __init init_prep_nvram(void)
+{
+	unsigned char *nvp;
+	int  i;
+	int  nvramSize;
+
+	/*
+	 * The following could fail if the NvRAM were corrupt but
+	 * we expect the boot firmware to have checked its checksum
+	 * before boot
+	 */
+	nvp = (char *) &nvram->Header;
+	for (i=0; i<sizeof(HEADER); i++)
+	{
+		*nvp = ppc_md.nvram_read_val(i);
+		nvp++;
+	}
+
+	/*
+	 * The PReP NvRAM may be any size so read in the header to
+	 * determine how much we must read in order to get the complete
+	 * GE area
+	 */
+	nvramSize=(int)nvram->Header.GEAddress+nvram->Header.GELength;
+	if(nvramSize>MAX_PREP_NVRAM)
+	{
+		/*
+		 * NvRAM is too large
+		 */
+		nvram->Header.GELength=0;
+		return;
+	}
+
+	/*
+	 * Read the remainder of the PReP NvRAM
+	 */
+	nvp = (char *) &nvram->GEArea[0];
+	for (i=sizeof(HEADER); i<nvramSize; i++)
+	{
+		*nvp = ppc_md.nvram_read_val(i);
+		nvp++;
+	}
+}
+
+char *prep_nvram_get_var(const char *name)
+{
+	char *cp;
+	int  namelen;
+
+	namelen = strlen(name);
+	cp = prep_nvram_first_var();
+	while (cp != NULL) {
+		if ((strncmp(name, cp, namelen) == 0)
+		    && (cp[namelen] == '='))
+		{
+			return cp+namelen+1;
+		}
+		cp = prep_nvram_next_var(cp);
+	}
+
+	return NULL;
+}
+
+char *prep_nvram_first_var(void)
+{
+        if (nvram->Header.GELength == 0) {
+		return NULL;
+	} else {
+		return (((char *)nvram)
+			+ ((unsigned int) nvram->Header.GEAddress));
+	}
+}
+
+char *prep_nvram_next_var(char *name)
+{
+	char *cp;
+
+
+	cp = name;
+	while (((cp - ((char *) nvram->GEArea)) < nvram->Header.GELength)
+	       && (*cp != '\0'))
+	{
+		cp++;
+	}
+
+	/* Skip over any null characters. */
+	while (((cp - ((char *) nvram->GEArea)) < nvram->Header.GELength)
+	       && (*cp == '\0'))
+	{
+		cp++;
+	}
+
+	if ((cp - ((char *) nvram->GEArea)) < nvram->Header.GELength) {
+		return cp;
+	} else {
+		return NULL;
+	}
+}
Index: working-2.6/arch/powerpc/platforms/prep/pci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/platforms/prep/pci.c	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,66 @@
+/*
+ * PReP pci functions.
+ * Originally by Gary Thomas
+ * rewritten and updated by Cort Dougan (cort@cs.nmt.edu)
+ *
+ * Adapted for ARCH=powerpc and a flattened device tree by
+ * Paul Mackerras <paulus@samba.org>
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/sections.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/ptrace.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/irq.h>
+#include <asm/machdep.h>
+#include <asm/mpic.h>
+
+void __init prep_pcibios_fixup(void)
+{
+	struct pci_dev *dev = NULL;
+
+	for_each_pci_dev(dev)
+		pci_read_irq_line(dev);
+}
+
+static void __init
+prep_pcibios_after_init(void)
+{
+}
+
+void __init prep_find_bridges(void)
+{
+	struct pci_controller* hose;
+	struct device_node *root = find_path_device("/");
+	struct device_node *dev;
+
+	for (dev = root->child; dev != NULL; dev = dev->sibling)
+		if (dev->type && strcmp(dev->type, "pci") == 0)
+			break;
+	if (!dev) {
+		printk(KERN_ERR "No PCI bridge in device tree\n");
+		return;
+	}
+	hose = pcibios_alloc_controller();
+	if (!hose)
+		return;
+
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+	pci_process_bridge_OF_ranges(hose, dev, 1);
+
+	setup_indirect_pci(hose, hose->io_base_phys + 0xcf8,
+			   hose->io_base_phys + 0xcfc);
+
+	printk("PReP architecture\n");
+
+	ppc_md.pcibios_fixup = prep_pcibios_fixup;
+	ppc_md.pcibios_after_init = prep_pcibios_after_init;
+}
Index: working-2.6/arch/powerpc/platforms/prep/setup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/platforms/prep/setup.c	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,720 @@
+/*
+ * Copyright (C) 1995  Linus Torvalds
+ * Adapted from 'alpha' version by Gary Thomas
+ * Modified by Cort Dougan (cort@cs.nmt.edu)
+ *
+ * Support for PReP (Motorola MTX/MVME)
+ * by Troy Benjegerdes (hozer@drgw.net)
+ *
+ * Port to arch/powerpc:
+ * Copyright 2007 David Gibson, IBM Corporation.
+ */
+
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <linux/initrd.h>
+
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpic.h>
+#include <asm/i8259.h>
+#include <asm/time.h>
+#include <asm/udbg.h>
+
+static const char *prep_model = "(unknown)";
+
+/* prep registers for L2 */
+#define CACHECRBA       0x80000823      /* Cache configuration register address */
+#define L2CACHE_MASK	0x03	/* Mask for 2 L2 Cache bits */
+#define L2CACHE_512KB	0x00	/* 512KB */
+#define L2CACHE_256KB	0x01	/* 256KB */
+#define L2CACHE_1MB	0x02	/* 1MB */
+#define L2CACHE_NONE	0x03	/* NONE */
+#define L2CACHE_PARITY  0x08    /* Mask for L2 Cache Parity Protected bit */
+
+#define PREP_PCI_DRAM_OFFSET 	0x80000000
+
+extern unsigned char prep_nvram_read_val(int addr);
+extern void prep_nvram_write_val(int addr,
+				 unsigned char val);
+extern void prep_pcibios_fixup(void);
+
+#ifdef CONFIG_SOUND_CS4232
+long ppc_cs4232_dma, ppc_cs4232_dma2;
+EXPORT_SYMBOL(ppc_cs4232_dma);
+EXPORT_SYMBOL(ppc_cs4232_dma2);
+#endif
+
+extern unsigned long loops_per_jiffy;
+
+/* useful ISA ports */
+#define PREP_SYSCTL	0x81c
+/* present in the IBM reference design; possibly identical in Mot boxes: */
+#define PREP_IBM_SIMM_ID	0x803	/* SIMM size: 32 or 8 MiB */
+#define PREP_IBM_SIMM_PRESENCE	0x804
+#define PREP_IBM_EQUIPMENT	0x80c
+#define PREP_IBM_L2INFO	0x80d
+#define PREP_IBM_PM1	0x82a	/* power management register 1 */
+#define PREP_IBM_PLANAR	0x852	/* planar ID - identifies the motherboard */
+#define PREP_IBM_DISP	0x8c0	/* 4-digit LED display */
+
+/* Equipment Present Register masks: */
+#define PREP_IBM_EQUIPMENT_RESERVED	0x80
+#define PREP_IBM_EQUIPMENT_SCSIFUSE	0x40
+#define PREP_IBM_EQUIPMENT_L2_COPYBACK	0x08
+#define PREP_IBM_EQUIPMENT_L2_256	0x04
+#define PREP_IBM_EQUIPMENT_CPU	0x02
+#define PREP_IBM_EQUIPMENT_L2	0x01
+
+/* planar ID values: */
+/* Sandalfoot/Sandalbow (6015/7020) */
+#define PREP_IBM_SANDALFOOT	0xfc
+/* Woodfield, Thinkpad 850/860 (6042/7249) */
+#define PREP_IBM_THINKPAD	0xff /* planar ID unimplemented */
+/* PowerSeries 830/850 (6050/6070) */
+#define PREP_IBM_CAROLINA_IDE_0	0xf0
+#define PREP_IBM_CAROLINA_IDE_1	0xf1
+#define PREP_IBM_CAROLINA_IDE_2	0xf2
+#define PREP_IBM_CAROLINA_IDE_3	0xf3
+/* 7248-43P */
+#define PREP_IBM_CAROLINA_SCSI_0	0xf4
+#define PREP_IBM_CAROLINA_SCSI_1	0xf5
+#define PREP_IBM_CAROLINA_SCSI_2	0xf6
+#define PREP_IBM_CAROLINA_SCSI_3	0xf7 /* missing from Carolina Tech Spec */
+/* Tiger1 (7043-140) */
+#define PREP_IBM_TIGER1_133		0xd1
+#define PREP_IBM_TIGER1_166		0xd2
+#define PREP_IBM_TIGER1_180		0xd3
+#define PREP_IBM_TIGER1_xxx		0xd4 /* unknown, but probably exists */
+#define PREP_IBM_TIGER1_333		0xd5 /* missing from Tiger Tech Spec */
+
+/*
+ * As found in the PReP reference implementation.
+ * Used by Thinkpad, Sandalfoot (6015/7020), and all Motorola PReP.
+ */
+static void __init prep_gen_enable_l2(void)
+{
+	outb(inb(PREP_SYSCTL) | 0x3, PREP_SYSCTL);
+}
+
+/* Used by Carolina and Tiger1 */
+static void __init prep_carolina_enable_l2(void)
+{
+	outb(inb(PREP_SYSCTL) | 0xc0, PREP_SYSCTL);
+}
+
+/* cpuinfo code common to all IBM PReP */
+static void prep_ibm_cpuinfo(struct seq_file *m)
+{
+	unsigned int equip_reg = inb(PREP_IBM_EQUIPMENT);
+
+	seq_printf(m, "machine\t\t: PReP %s\n", prep_model);
+
+	seq_printf(m, "upgrade cpu\t: ");
+	if (equip_reg & PREP_IBM_EQUIPMENT_CPU) {
+		seq_printf(m, "not ");
+	}
+	seq_printf(m, "present\n");
+
+	/* print info about the SCSI fuse */
+	seq_printf(m, "scsi fuse\t: ");
+	if (equip_reg & PREP_IBM_EQUIPMENT_SCSIFUSE)
+		seq_printf(m, "ok");
+	else
+		seq_printf(m, "bad");
+	seq_printf(m, "\n");
+}
+
+static void prep_sandalfoot_cpuinfo(struct seq_file *m)
+{
+	unsigned int equip_reg = inb(PREP_IBM_EQUIPMENT);
+
+	prep_ibm_cpuinfo(m);
+
+	/* report amount and type of L2 cache present */
+	seq_printf(m, "L2 cache\t: ");
+	if (equip_reg & PREP_IBM_EQUIPMENT_L2) {
+		seq_printf(m, "not present");
+	} else {
+		if (equip_reg & PREP_IBM_EQUIPMENT_L2_256)
+			seq_printf(m, "256KiB");
+		else
+			seq_printf(m, "unknown size");
+
+		if (equip_reg & PREP_IBM_EQUIPMENT_L2_COPYBACK)
+			seq_printf(m, ", copy-back");
+		else
+			seq_printf(m, ", write-through");
+	}
+	seq_printf(m, "\n");
+}
+
+static void prep_thinkpad_cpuinfo(struct seq_file *m)
+{
+	unsigned int equip_reg = inb(PREP_IBM_EQUIPMENT);
+	char *cpubus_speed, *pci_speed;
+
+	prep_ibm_cpuinfo(m);
+
+	/* report amount and type of L2 cache present */
+	seq_printf(m, "l2 cache\t: ");
+	if (!(equip_reg & 0x1)) {
+		switch ((equip_reg & 0xc) >> 2) {
+		case 0x0:
+			seq_printf(m, "128KiB look-aside 2-way write-through\n");
+			break;
+		case 0x1:
+			seq_printf(m, "512KiB look-aside direct-mapped write-back\n");
+			break;
+		case 0x2:
+			seq_printf(m, "256KiB look-aside 2-way write-through\n");
+			break;
+		case 0x3:
+			seq_printf(m, "256KiB look-aside direct-mapped write-back\n");
+			break;
+		}
+	} else {
+		seq_printf(m, "not present\n");
+	}
+
+	/* report bus speeds because we can */
+	if ((equip_reg & 0x80) == 0) {
+		switch ((equip_reg & 0x30) >> 4) {
+		case 0x1:
+			cpubus_speed = "50";
+			pci_speed = "25";
+			break;
+		case 0x3:
+			cpubus_speed = "66";
+			pci_speed = "33";
+			break;
+		default:
+			cpubus_speed = "unknown";
+			pci_speed = "unknown";
+			break;
+		}
+	} else {
+		switch ((equip_reg & 0x30) >> 4) {
+		case 0x1:
+			cpubus_speed = "25";
+			pci_speed = "25";
+			break;
+		case 0x2:
+			cpubus_speed = "60";
+			pci_speed = "30";
+			break;
+		case 0x3:
+			cpubus_speed = "33";
+			pci_speed = "33";
+			break;
+		default:
+			cpubus_speed = "unknown";
+			pci_speed = "unknown";
+			break;
+		}
+	}
+	seq_printf(m, "60x bus\t\t: %sMHz\n", cpubus_speed);
+	seq_printf(m, "pci bus\t\t: %sMHz\n", pci_speed);
+}
+
+static void prep_carolina_cpuinfo(struct seq_file *m)
+{
+	unsigned int equip_reg = inb(PREP_IBM_EQUIPMENT);
+
+	prep_ibm_cpuinfo(m);
+
+	/* report amount and type of L2 cache present */
+	seq_printf(m, "l2 cache\t: ");
+	if ((equip_reg & 0x1) == 0) {
+		unsigned int l2_reg = inb(PREP_IBM_L2INFO);
+
+		/* L2 size */
+		if ((l2_reg & 0x60) == 0)
+			seq_printf(m, "256KiB");
+		else if ((l2_reg & 0x60) == 0x20)
+			seq_printf(m, "512KiB");
+		else
+			seq_printf(m, "unknown size");
+
+		/* L2 type */
+		if ((l2_reg & 0x3) == 0)
+			seq_printf(m, ", async");
+		else if ((l2_reg & 0x3) == 1)
+			seq_printf(m, ", sync");
+		else
+			seq_printf(m, ", unknown type");
+
+		seq_printf(m, "\n");
+	} else {
+		seq_printf(m, "not present\n");
+	}
+}
+
+static void prep_tiger1_cpuinfo(struct seq_file *m)
+{
+	unsigned int l2_reg = inb(PREP_IBM_L2INFO);
+
+	prep_ibm_cpuinfo(m);
+
+	/* report amount and type of L2 cache present */
+	seq_printf(m, "l2 cache\t: ");
+	if ((l2_reg & 0xf) == 0xf) {
+		seq_printf(m, "not present\n");
+	} else {
+		if (l2_reg & 0x8)
+			seq_printf(m, "async, ");
+		else
+			seq_printf(m, "sync burst, ");
+
+		if (l2_reg & 0x4)
+			seq_printf(m, "parity, ");
+		else
+			seq_printf(m, "no parity, ");
+
+		switch (l2_reg & 0x3) {
+		case 0x0:
+			seq_printf(m, "256KiB\n");
+			break;
+		case 0x1:
+			seq_printf(m, "512KiB\n");
+			break;
+		case 0x2:
+			seq_printf(m, "1MiB\n");
+			break;
+		default:
+			seq_printf(m, "unknown size\n");
+			break;
+		}
+	}
+}
+
+/* Used by all Motorola PReP */
+static void prep_mot_cpuinfo(struct seq_file *m)
+{
+	unsigned int cachew = *((unsigned char *)CACHECRBA);
+
+	seq_printf(m, "machine\t\t: PReP %s\n", prep_model);
+
+	/* report amount and type of L2 cache present */
+	seq_printf(m, "l2 cache\t: ");
+	switch (cachew & L2CACHE_MASK) {
+	case L2CACHE_512KB:
+		seq_printf(m, "512KiB");
+		break;
+	case L2CACHE_256KB:
+		seq_printf(m, "256KiB");
+		break;
+	case L2CACHE_1MB:
+		seq_printf(m, "1MiB");
+		break;
+	case L2CACHE_NONE:
+		seq_printf(m, "none\n");
+		return;
+	default:
+		seq_printf(m, "%x\n", cachew);
+	}
+
+	seq_printf(m, ", parity %s",
+			(cachew & L2CACHE_PARITY)? "enabled" : "disabled");
+
+	seq_printf(m, " SRAM:");
+
+	switch ( ((cachew & 0xf0) >> 4) & ~(0x3) ) {
+	case 1:
+		seq_printf(m, "synchronous, parity, flow-through\n");
+		break;
+	case 2:
+		seq_printf(m, "asynchronous, no parity\n");
+		break;
+	case 3:
+		seq_printf(m, "asynchronous, parity\n");
+		break;
+	default:
+		seq_printf(m, "synchronous, pipelined, no parity\n");
+		break;
+	}
+}
+
+static void prep_restart(char *cmd)
+{
+	local_irq_disable(); /* no interrupts */
+
+	/* set exception prefix high - to the prom */
+	mtmsr(mfmsr() | MSR_IP);
+
+	/* make sure bit 0 (reset) is a 0 */
+	outb(inb(0x92) & ~1L, 0x92);
+	/* signal a reset to system control port A - soft reset */
+	outb(inb(0x92) | 1, 0x92);
+
+	for (;;)
+		;
+	/* not reached */
+}
+
+static void prep_halt(void)
+{
+	local_irq_disable(); /* no interrupts */
+
+	/* set exception prefix high - to the prom */
+	mtmsr(mfmsr() | MSR_IP);
+
+	for (;;)
+		;
+	/* not reached */
+}
+
+/*
+ * On most IBM PReP's, power management is handled by a Signetics 87c750
+ * behind the Utah component on the ISA bus. To access the 750 you must write
+ * a series of nibbles to port 0x82a (decoded by the Utah). This is described
+ * somewhat in the IBM Carolina Technical Specification.
+ * -Hollis
+ */
+static void
+utah_sig87c750_setbit(unsigned int bytenum, unsigned int bitnum, int value)
+{
+	/*
+	 * byte1: 0 0 0 1 0  d  a5 a4
+	 * byte2: 0 0 0 1 a3 a2 a1 a0
+	 *
+	 * d = the bit's value, enabled or disabled
+	 * (a5 a4 a3) = the byte number, minus 20
+	 * (a2 a1 a0) = the bit number
+	 *
+	 * example: set the 5th bit of byte 21 (21.5)
+	 *     a5 a4 a3 = 001 (byte 1)
+	 *     a2 a1 a0 = 101 (bit 5)
+	 *
+	 *     byte1 = 0001 0100 (0x14)
+	 *     byte2 = 0001 1101 (0x1d)
+	 */
+	unsigned char byte1=0x10, byte2=0x10;
+
+	/* the 750's '20.0' is accessed as '0.0' through Utah (which adds 20) */
+	bytenum -= 20;
+
+	byte1 |= (!!value) << 2;		/* set d */
+	byte1 |= (bytenum >> 1) & 0x3;	/* set a5, a4 */
+
+	byte2 |= (bytenum & 0x1) << 3;	/* set a3 */
+	byte2 |= bitnum & 0x7;			/* set a2, a1, a0 */
+
+	outb(byte1, PREP_IBM_PM1);	/* first nibble */
+	mb();
+	udelay(100);				/* important: let controller recover */
+
+	outb(byte2, PREP_IBM_PM1);	/* second nibble */
+	mb();
+	udelay(100);				/* important: let controller recover */
+}
+
+static void prep_sig750_poweroff(void)
+{
+	/* tweak the power manager found in most IBM PRePs (except Thinkpads) */
+
+	local_irq_disable();
+	/* set exception prefix high - to the prom */
+	mtmsr(mfmsr() | MSR_IP);
+
+	utah_sig87c750_setbit(21, 5, 1); /* set bit 21.5, "PMEXEC_OFF" */
+
+	for (;;)
+		;
+	/* not reached */
+}
+
+static void __init prep_find_bridges(void)
+{
+	struct device_node *phb;
+	struct pci_controller *hose;
+
+	phb = of_find_node_by_type(NULL, "pci");
+	if (!phb) {
+		printk(KERN_ERR "PReP: Cannot find PCI bridge OF node\n");
+		return;
+	}
+
+	hose = pcibios_alloc_controller();
+	if (!hose)
+		return;
+
+	pci_process_bridge_OF_ranges(hose, phb, 1);
+
+	pci_dram_offset = PREP_PCI_DRAM_OFFSET;
+	ISA_DMA_THRESHOLD = 0x00ffffff;
+	DMA_MODE_READ = 0x44;
+	DMA_MODE_WRITE = 0x48;
+
+	setup_indirect_pci(hose, hose->io_base_phys + 0xcf8,
+			   hose->io_base_phys + 0xcfc);
+}
+
+static void __init prep_setup_arch(void)
+{
+	struct device_node *root;
+	const char *model;
+	u8 reg;
+
+	root = of_find_node_by_path("/");
+	model = of_get_property(root, "model", NULL);
+	of_node_put(root);
+	if (model)
+		prep_model = model;
+
+	/* init to some ~sane value until calibrate_delay() runs */
+	loops_per_jiffy = 50000000; /**/
+
+	/* Lookup PCI host bridges */
+	prep_find_bridges();
+
+	/* Set up floppy in PS/2 mode */
+	outb(0x09, SIO_CONFIG_RA);
+	reg = inb(SIO_CONFIG_RD);
+	reg = (reg & 0x3F) | 0x40;
+	outb(reg, SIO_CONFIG_RD);
+	outb(reg, SIO_CONFIG_RD);	/* Have to write twice to change! */
+
+	if (strncmp(prep_model, "IBM,", 4) == 0) {
+		reg = inb(PREP_IBM_PLANAR);
+		printk(KERN_INFO "PReP: IBM planar ID: %02x\n", reg);
+		switch (reg) {
+		case PREP_IBM_SANDALFOOT:
+			prep_gen_enable_l2();
+			ppc_md.power_off = prep_sig750_poweroff;
+			ppc_md.show_cpuinfo = prep_sandalfoot_cpuinfo;
+			break;
+		case PREP_IBM_THINKPAD:
+			prep_gen_enable_l2();
+			/* Carrera is the power manager in the
+			 * Thinkpads. Unfortunately not much is known
+			 * about it, so we can't power down.
+			 */
+			ppc_md.show_cpuinfo = prep_thinkpad_cpuinfo;
+			break;
+		case PREP_IBM_CAROLINA_IDE_0:
+		case PREP_IBM_CAROLINA_IDE_1:
+		case PREP_IBM_CAROLINA_IDE_2:
+		case PREP_IBM_CAROLINA_IDE_3:
+		case PREP_IBM_CAROLINA_SCSI_0:
+		case PREP_IBM_CAROLINA_SCSI_1:
+		case PREP_IBM_CAROLINA_SCSI_2:
+		case PREP_IBM_CAROLINA_SCSI_3:
+			prep_carolina_enable_l2();
+			ppc_md.power_off = prep_sig750_poweroff;
+			ppc_md.show_cpuinfo = prep_carolina_cpuinfo;
+			break;
+		case PREP_IBM_TIGER1_133:
+		case PREP_IBM_TIGER1_166:
+		case PREP_IBM_TIGER1_180:
+		case PREP_IBM_TIGER1_xxx:
+		case PREP_IBM_TIGER1_333:
+			prep_carolina_enable_l2();
+			ppc_md.power_off = prep_sig750_poweroff;
+			ppc_md.show_cpuinfo = prep_tiger1_cpuinfo;
+			break;
+		default:
+			prep_gen_enable_l2();
+			break;
+		}
+	} else {
+		/* _PREP_Motorola */
+		prep_gen_enable_l2();
+		ppc_md.show_cpuinfo = prep_mot_cpuinfo;
+	}
+
+	/* Read in NVRAM data */
+/* 	init_prep_nvram(); */
+}
+
+static struct mpic *prep_mpic;
+
+static void __init prep_find_openpic(void)
+{
+	struct device_node *np;
+	struct resource r;
+	unsigned long opaddr;
+
+	np = of_find_node_by_type(NULL, "open-pic");
+	if (!np)
+		return;
+
+	if (of_address_to_resource(np, 0, &r))
+		goto bail;
+	opaddr = r.start;
+
+	printk(KERN_INFO "OpenPIC at %lx\n", opaddr);
+
+	prep_mpic = mpic_alloc(np, opaddr, MPIC_PRIMARY, 0, 0, " MPIC    ");
+	if (!prep_mpic) {
+		printk(KERN_ERR "Failed to allocate MPIC structure\n");
+		goto bail;
+	}
+	mpic_init(prep_mpic);
+	ppc_md.get_irq = mpic_get_irq;
+
+ bail:
+	of_node_put(np);
+}
+
+static void prep_8259_cascade(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int cascade_irq = i8259_irq();
+	if (cascade_irq != NO_IRQ)
+		generic_handle_irq(cascade_irq);
+	desc->chip->eoi(irq);
+}
+
+static void __init prep_find_8259(void)
+{
+	struct device_node *np;
+	struct device_node *pic = NULL;
+	unsigned long int_ack = 0;
+	unsigned int cascade_irq;
+
+	pic = of_find_node_by_type(NULL, "i8259");
+	if (!pic) {
+		if (!prep_mpic)
+			printk(KERN_ERR "No interrupt controller found!\n");
+		return;
+	}
+
+	for_each_node_by_type(np, "pci") {
+		const unsigned int *addrp = of_get_property(np,
+				"8259-interrupt-acknowledge", NULL);
+
+		if (!addrp)
+			continue;
+		int_ack = addrp[of_n_addr_cells(np)-1];
+		break;
+	}
+	if (!np)
+		printk(KERN_WARNING "Cannot find PCI interrupt acknowledge"
+		       " address, polling\n");
+
+	i8259_init(pic, int_ack);
+	if (!ppc_md.get_irq)
+		ppc_md.get_irq = i8259_irq;
+	if (prep_mpic) {
+		cascade_irq = irq_of_parse_and_map(pic, 0);
+		if (cascade_irq == NO_IRQ)
+			printk(KERN_ERR "i8259: failed to map cascade irq\n");
+		else
+			set_irq_chained_handler(cascade_irq,
+						prep_8259_cascade);
+	}
+}
+
+static void __init prep_init_IRQ(void)
+{
+	prep_find_openpic();
+	prep_find_8259();
+}
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+/*
+ * IDE stuff.
+ */
+static int prep_ide_default_irq(unsigned long base)
+{
+	switch (base) {
+	case 0x1f0: return 13;
+	case 0x170: return 13;
+	case 0x1e8: return 11;
+	case 0x168: return 10;
+	case 0xfff0: return 14;		/* MCP(N)750 ide0 */
+	case 0xffe0: return 15;		/* MCP(N)750 ide1 */
+	default: return 0;
+	}
+}
+
+static unsigned long prep_ide_default_io_base(int index)
+{
+	switch (index) {
+	case 0: return 0x1f0;
+	case 1: return 0x170;
+	case 2: return 0x1e8;
+	case 3: return 0x168;
+	default:
+		return 0;
+	}
+}
+#endif
+
+#if 0
+static int __init prep_request_io(void)
+{
+#ifdef CONFIG_NVRAM
+	request_region(PREP_NVRAM_AS0, 0x8, "nvram");
+#endif
+	request_region(0x00,0x20,"dma1");
+	request_region(0x40,0x20,"timer");
+	request_region(0x80,0x10,"dma page reg");
+	request_region(0xc0,0x20,"dma2");
+
+	return 0;
+}
+device_initcall(prep_request_io);
+#endif
+
+#ifdef CONFIG_SMP
+static void __init smp_prep_kick_cpu(int nr)
+{
+	*(unsigned long *)KERNELBASE = nr;
+	asm volatile("dcbf 0,%0"::"r"(KERNELBASE):"memory");
+	printk("CPU1 released, waiting\n");
+}
+
+static void __init smp_prep_setup_cpu(int cpu_nr)
+{
+	if (prep_mpic)
+		mpic_setup_this_cpu();
+}
+
+static struct smp_ops_t prep_smp_ops = {
+	.message_pass = smp_mpic_message_pass,
+	.probe = smp_mpic_probe,
+	.kick_cpu = smp_prep_kick_cpu,
+	.setup_cpu = smp_prep_setup_cpu,
+	.give_timebase = smp_generic_give_timebase,
+	.take_timebase = smp_generic_take_timebase,
+};
+#endif /* CONFIG_SMP */
+
+static int __init prep_probe(void)
+{
+	if (! of_flat_dt_is_compatible(of_get_flat_dt_root(), "prep"))
+		return 0;
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+	ppc_ide_md.default_irq = prep_ide_default_irq;
+	ppc_ide_md.default_io_base = prep_ide_default_io_base;
+#endif
+
+#ifdef CONFIG_SMP
+	smp_ops			 = &prep_smp_ops;
+#endif /* CONFIG_SMP */
+
+	return 1;
+}
+
+define_machine(prep) {
+	.name			= "PReP",
+	.probe			= prep_probe,
+	.setup_arch		= prep_setup_arch,
+	.show_cpuinfo		= prep_ibm_cpuinfo, /* Overriden for some variants */
+	.init_IRQ		= prep_init_IRQ,
+/* 	.pcibios_fixup		= prep_pcibios_fixup, */
+	.restart		= prep_restart, /* Overriden for some variants */
+	.power_off		= prep_halt,/* Overriden for some variants */
+	.halt			= prep_halt,/* Overriden for some variants */
+/* 	.time_init		= todc_time_init, */
+/* 	.set_rtc_time		= todc_set_rtc_time, */
+/* 	.get_rtc_time		= todc_get_rtc_time, */
+	.calibrate_decr		= generic_calibrate_decr,
+	.progress		= udbg_progress,
+/* 	.nvram_read_val		= prep_nvram_read_val, */
+/* 	.nvram_write_val	= prep_nvram_write_val, */
+	.phys_mem_access_prot	= pci_phys_mem_access_prot,
+};
Index: working-2.6/include/asm-powerpc/residual.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/include/asm-powerpc/residual.h	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,350 @@
+/* 7/18/95                                                                    */
+/*----------------------------------------------------------------------------*/
+/*      Residual Data header definitions and prototypes                       */
+/*----------------------------------------------------------------------------*/
+
+/* Structure map for RESIDUAL on PowerPC Reference Platform                   */
+/* residual.h - Residual data structure passed in r3.                         */
+/*              Load point passed in r4 to boot image.                        */
+/* For enum's: if given in hex then they are bit significant,                 */
+/*             i.e. only one bit is on for each enum                          */
+/* Reserved fields must be filled with zeros.                                */
+
+#ifdef __KERNEL__
+#ifndef _RESIDUAL_
+#define _RESIDUAL_
+
+#ifndef __ASSEMBLY__
+
+#define MAX_CPUS 32                     /* These should be set to the maximum */
+#define MAX_MEMS 64                     /* number possible for this system.   */
+#define MAX_DEVICES 256                 /* Changing these will change the     */
+#define AVE_PNP_SIZE 32                 /* structure, hence the version of    */
+#define MAX_MEM_SEGS 64                 /* this header file.                  */
+
+/*----------------------------------------------------------------------------*/
+/*               Public structures...                                         */
+/*----------------------------------------------------------------------------*/
+
+#include <asm/prep/pnp.h>
+
+typedef enum _L1CACHE_TYPE {
+  NoneCAC = 0,
+  SplitCAC = 1,
+  CombinedCAC = 2
+  } L1CACHE_TYPE;
+
+typedef enum _TLB_TYPE {
+  NoneTLB = 0,
+  SplitTLB = 1,
+  CombinedTLB = 2
+  } TLB_TYPE;
+
+typedef enum _FIRMWARE_SUPPORT {
+  Conventional = 0x01,
+  OpenFirmware = 0x02,
+  Diagnostics = 0x04,
+  LowDebug = 0x08,
+  Multiboot = 0x10,
+  LowClient = 0x20,
+  Hex41 = 0x40,
+  FAT = 0x80,
+  ISO9660 = 0x0100,
+  SCSI_InitiatorID_Override = 0x0200,
+  Tape_Boot = 0x0400,
+  FW_Boot_Path = 0x0800
+  } FIRMWARE_SUPPORT;
+
+typedef enum _FIRMWARE_SUPPLIERS {
+  IBMFirmware = 0x00,
+  MotoFirmware = 0x01,                  /* 7/18/95                            */
+  FirmWorks = 0x02,                     /* 10/5/95                            */
+  Bull = 0x03,                          /* 04/03/96                           */
+  } FIRMWARE_SUPPLIERS;
+
+typedef enum _ENDIAN_SWITCH_METHODS {
+  UsePort92 = 0x01,
+  UsePCIConfigA8 = 0x02,
+  UseFF001030 = 0x03,
+  } ENDIAN_SWITCH_METHODS;
+
+typedef enum _SPREAD_IO_METHODS {
+  UsePort850 = 0x00,
+/*UsePCIConfigA8 = 0x02,*/
+  } SPREAD_IO_METHODS;
+
+typedef struct _VPD {
+
+  /* Box dependent stuff */
+  unsigned char PrintableModel[32];     /* Null terminated string.
+                                           Must be of the form:
+                                           vvv,<20h>,<model designation>,<0x0>
+                                           where vvv is the vendor ID
+                                           e.g. IBM PPS MODEL 6015<0x0>       */
+  unsigned char Serial[16];             /* 12/94:
+                                           Serial Number; must be of the form:
+                                           vvv<serial number> where vvv is the
+                                           vendor ID.
+                                           e.g. IBM60151234567<20h><20h>      */
+  unsigned char Reserved[48];
+  unsigned long FirmwareSupplier;       /* See FirmwareSuppliers enum         */
+  unsigned long FirmwareSupports;       /* See FirmwareSupport enum           */
+  unsigned long NvramSize;              /* Size of nvram in bytes             */
+  unsigned long NumSIMMSlots;
+  unsigned short EndianSwitchMethod;    /* See EndianSwitchMethods enum       */
+  unsigned short SpreadIOMethod;        /* See SpreadIOMethods enum           */
+  unsigned long SmpIar;
+  unsigned long RAMErrLogOffset;        /* Heap offset to error log           */
+  unsigned long Reserved5;
+  unsigned long Reserved6;
+  unsigned long ProcessorHz;            /* Processor clock frequency in Hertz */
+  unsigned long ProcessorBusHz;         /* Processor bus clock frequency      */
+  unsigned long Reserved7;
+  unsigned long TimeBaseDivisor;        /* (Bus clocks per timebase tic)*1000 */
+  unsigned long WordWidth;              /* Word width in bits                 */
+  unsigned long PageSize;               /* Page size in bytes                 */
+  unsigned long CoherenceBlockSize;     /* Unit of transfer in/out of cache
+                                           for which coherency is maintained;
+                                           normally <= CacheLineSize.         */
+  unsigned long GranuleSize;            /* Unit of lock allocation to avoid   */
+                                        /*   false sharing of locks.          */
+
+  /* L1 Cache variables */
+  unsigned long CacheSize;              /* L1 Cache size in KB. This is the   */
+                                        /*   total size of the L1, whether    */
+                                        /*   combined or split                */
+  unsigned long CacheAttrib;            /* L1CACHE_TYPE                       */
+  unsigned long CacheAssoc;             /* L1 Cache associativity. Use this
+                                           for combined cache. If split, put
+                                           zeros here.                        */
+  unsigned long CacheLineSize;          /* L1 Cache line size in bytes. Use
+                                           for combined cache. If split, put
+                                           zeros here.                        */
+  /* For split L1 Cache: (= combined if combined cache) */
+  unsigned long I_CacheSize;
+  unsigned long I_CacheAssoc;
+  unsigned long I_CacheLineSize;
+  unsigned long D_CacheSize;
+  unsigned long D_CacheAssoc;
+  unsigned long D_CacheLineSize;
+
+  /* Translation Lookaside Buffer variables */
+  unsigned long TLBSize;                /* Total number of TLBs on the system */
+  unsigned long TLBAttrib;              /* Combined I+D or split TLB          */
+  unsigned long TLBAssoc;               /* TLB Associativity. Use this for
+                                           combined TLB. If split, put zeros
+                                           here.                              */
+  /* For split TLB: (= combined if combined TLB) */
+  unsigned long I_TLBSize;
+  unsigned long I_TLBAssoc;
+  unsigned long D_TLBSize;
+  unsigned long D_TLBAssoc;
+
+  unsigned long ExtendedVPD;            /* Offset to extended VPD area;
+                                           null if unused                     */
+  } VPD;
+
+typedef enum _DEVICE_FLAGS {
+  Enabled = 0x4000,                     /* 1 - PCI device is enabled          */
+  Integrated = 0x2000,
+  Failed = 0x1000,                      /* 1 - device failed POST code tests  */
+  Static = 0x0800,                      /* 0 - dynamically configurable
+                                           1 - static                         */
+  Dock = 0x0400,                        /* 0 - not a docking station device
+                                           1 - is a docking station device    */
+  Boot = 0x0200,                        /* 0 - device cannot be used for BOOT
+                                           1 - can be a BOOT device           */
+  Configurable = 0x0100,                /* 1 - device is configurable         */
+  Disableable = 0x80,                   /* 1 - device can be disabled         */
+  PowerManaged = 0x40,                  /* 0 - not managed; 1 - managed       */
+  ReadOnly = 0x20,                      /* 1 - device is read only            */
+  Removable = 0x10,                     /* 1 - device is removable            */
+  ConsoleIn = 0x08,
+  ConsoleOut = 0x04,
+  Input = 0x02,
+  Output = 0x01
+  } DEVICE_FLAGS;
+
+typedef enum _BUS_ID {
+  ISADEVICE = 0x01,
+  EISADEVICE = 0x02,
+  PCIDEVICE = 0x04,
+  PCMCIADEVICE = 0x08,
+  PNPISADEVICE = 0x10,
+  MCADEVICE = 0x20,
+  MXDEVICE = 0x40,                      /* Devices on mezzanine bus           */
+  PROCESSORDEVICE = 0x80,               /* Devices on processor bus           */
+  VMEDEVICE = 0x100,
+  } BUS_ID;
+
+typedef struct _DEVICE_ID {
+  unsigned long BusId;                  /* See BUS_ID enum above              */
+  unsigned long DevId;                  /* Big Endian format                  */
+  unsigned long SerialNum;              /* For multiple usage of a single
+                                           DevId                              */
+  unsigned long Flags;                  /* See DEVICE_FLAGS enum above        */
+  unsigned char BaseType;               /* See pnp.h for bit definitions      */
+  unsigned char SubType;                /* See pnp.h for bit definitions      */
+  unsigned char Interface;              /* See pnp.h for bit definitions      */
+  unsigned char Spare;
+  } DEVICE_ID;
+
+typedef union _BUS_ACCESS {
+  struct _PnPAccess{
+    unsigned char CSN;
+    unsigned char LogicalDevNumber;
+    unsigned short ReadDataPort;
+    } PnPAccess;
+  struct _ISAAccess{
+    unsigned char SlotNumber;           /* ISA Slot Number generally not
+                                           available; 0 if unknown            */
+    unsigned char LogicalDevNumber;
+    unsigned short ISAReserved;
+    } ISAAccess;
+  struct _MCAAccess{
+    unsigned char SlotNumber;
+    unsigned char LogicalDevNumber;
+    unsigned short MCAReserved;
+    } MCAAccess;
+  struct _PCMCIAAccess{
+    unsigned char SlotNumber;
+    unsigned char LogicalDevNumber;
+    unsigned short PCMCIAReserved;
+    } PCMCIAAccess;
+  struct _EISAAccess{
+    unsigned char SlotNumber;
+    unsigned char FunctionNumber;
+    unsigned short EISAReserved;
+    } EISAAccess;
+  struct _PCIAccess{
+    unsigned char BusNumber;
+    unsigned char DevFuncNumber;
+    unsigned short PCIReserved;
+    } PCIAccess;
+  struct _ProcBusAccess{
+    unsigned char BusNumber;
+    unsigned char BUID;
+    unsigned short ProcBusReserved;
+    } ProcBusAccess;
+  } BUS_ACCESS;
+
+/* Per logical device information */
+typedef struct _PPC_DEVICE {
+  DEVICE_ID DeviceId;
+  BUS_ACCESS BusAccess;
+
+  /* The following three are offsets into the DevicePnPHeap */
+  /* All are in PnP compressed format                       */
+  unsigned long AllocatedOffset;        /* Allocated resource description     */
+  unsigned long PossibleOffset;         /* Possible resource description      */
+  unsigned long CompatibleOffset;       /* Compatible device identifiers      */
+  } PPC_DEVICE;
+
+typedef enum _CPU_STATE {
+  CPU_GOOD = 0,                         /* CPU is present, and active         */
+  CPU_GOOD_FW = 1,                      /* CPU is present, and in firmware    */
+  CPU_OFF = 2,                          /* CPU is present, but inactive       */
+  CPU_FAILED = 3,                       /* CPU is present, but failed POST    */
+  CPU_NOT_PRESENT = 255                 /* CPU not present                    */
+  } CPU_STATE;
+
+typedef struct _PPC_CPU {
+  unsigned long CpuType;                /* Result of mfspr from Processor
+                                           Version Register (PVR).
+                                           PVR(0-15) = Version (e.g. 601)
+                                           PVR(16-31 = EC Level               */
+  unsigned char CpuNumber;              /* CPU Number for this processor      */
+  unsigned char CpuState;               /* CPU State, see CPU_STATE enum      */
+  unsigned short Reserved;
+  } PPC_CPU;
+
+typedef struct _PPC_MEM {
+  unsigned long SIMMSize;               /* 0 - absent or bad
+                                           8M, 32M (in MB)                    */
+  } PPC_MEM;
+
+typedef enum _MEM_USAGE {
+  Other = 0x8000,
+  ResumeBlock = 0x4000,                 /* for use by power management        */
+  SystemROM = 0x2000,                   /* Flash memory (populated)           */
+  UnPopSystemROM = 0x1000,              /* Unpopulated part of SystemROM area */
+  IOMemory = 0x0800,
+  SystemIO = 0x0400,
+  SystemRegs = 0x0200,
+  PCIAddr = 0x0100,
+  PCIConfig = 0x80,
+  ISAAddr = 0x40,
+  Unpopulated = 0x20,                   /* Unpopulated part of System Memory  */
+  Free = 0x10,                          /* Free part of System Memory         */
+  BootImage = 0x08,                     /* BootImage part of System Memory    */
+  FirmwareCode = 0x04,                  /* FirmwareCode part of System Memory */
+  FirmwareHeap = 0x02,                  /* FirmwareHeap part of System Memory */
+  FirmwareStack = 0x01                  /* FirmwareStack part of System Memory*/
+  } MEM_USAGE;
+
+typedef struct _MEM_MAP {
+  unsigned long Usage;                  /* See MEM_USAGE above                */
+  unsigned long BasePage;               /* Page number measured in 4KB pages  */
+  unsigned long PageCount;              /* Page count measured in 4KB pages   */
+  } MEM_MAP;
+
+typedef struct _RESIDUAL {
+  unsigned long ResidualLength;         /* Length of Residual                 */
+  unsigned char Version;                /* of this data structure             */
+  unsigned char Revision;               /* of this data structure             */
+  unsigned short EC;                    /* of this data structure             */
+  /* VPD */
+  VPD VitalProductData;
+  /* CPU */
+  unsigned short MaxNumCpus;            /* Max CPUs in this system            */
+  unsigned short ActualNumCpus;         /* ActualNumCpus < MaxNumCpus means   */
+                                        /* that there are unpopulated or      */
+                                        /* otherwise unusable cpu locations   */
+  PPC_CPU Cpus[MAX_CPUS];
+  /* Memory */
+  unsigned long TotalMemory;            /* Total amount of memory installed   */
+  unsigned long GoodMemory;             /* Total amount of good memory        */
+  unsigned long ActualNumMemSegs;
+  MEM_MAP Segs[MAX_MEM_SEGS];
+  unsigned long ActualNumMemories;
+  PPC_MEM Memories[MAX_MEMS];
+  /* Devices */
+  unsigned long ActualNumDevices;
+  PPC_DEVICE Devices[MAX_DEVICES];
+  unsigned char DevicePnPHeap[2*MAX_DEVICES*AVE_PNP_SIZE];
+  } RESIDUAL;
+
+
+/*
+ * Forward declaration - we can't include <linux/pci.h> because it
+ * breaks the boot loader
+ */
+struct pci_dev;
+
+extern RESIDUAL *res;
+extern void print_residual_device_info(void);
+extern PPC_DEVICE *residual_find_device(unsigned long BusMask,
+					unsigned char * DevID, int BaseType,
+					int SubType, int Interface, int n);
+extern int residual_pcidev_irq(struct pci_dev *dev);
+extern void residual_irq_mask(char *irq_edge_mask_lo, char *irq_edge_mask_hi);
+extern unsigned int residual_isapic_addr(void);
+extern PnP_TAG_PACKET *PnP_find_packet(unsigned char *p, unsigned packet_tag,
+				       int n);
+extern PnP_TAG_PACKET *PnP_find_small_vendor_packet(unsigned char *p,
+						    unsigned packet_type,
+						    int n);
+extern PnP_TAG_PACKET *PnP_find_large_vendor_packet(unsigned char *p,
+						    unsigned packet_type,
+						    int n);
+
+#ifdef CONFIG_PREP_RESIDUAL
+#define have_residual_data	(res && res->ResidualLength)
+#else
+#define have_residual_data	0
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif  /* ndef _RESIDUAL_ */
+
+#endif /* __KERNEL__ */
Index: working-2.6/arch/powerpc/boot/pnp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/boot/pnp.h	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,640 @@
+#ifndef _PPC_BOOT_PNP_H_
+#define _PPC_BOOT_PNP_H_
+/* 11/02/95                                                                   */
+/*----------------------------------------------------------------------------*/
+/*      Plug and Play header definitions                                      */
+/*----------------------------------------------------------------------------*/
+
+/* Structure map for PnP on PowerPC Reference Platform                        */
+/* See Plug and Play ISA Specification, Version 1.0, May 28, 1993.  It        */
+/* (or later versions) is available on Compuserve in the PLUGPLAY area.       */
+/* This code has extensions to that specification, namely new short and       */
+/* long tag types for platform dependent information                          */
+
+/* Warning: LE notation used throughout this file                             */
+
+/* For enum's: if given in hex then they are bit significant, i.e.            */
+/* only one bit is on for each enum                                           */
+
+#define MAX_MEM_REGISTERS 9
+#define MAX_IO_PORTS 20
+#define MAX_IRQS 7
+/*#define MAX_DMA_CHANNELS 7*/
+
+/* Interrupt controllers */
+
+#define PNPinterrupt0 "PNP0000"      /* AT Interrupt Controller               */
+#define PNPinterrupt1 "PNP0001"      /* EISA Interrupt Controller             */
+#define PNPinterrupt2 "PNP0002"      /* MCA Interrupt Controller              */
+#define PNPinterrupt3 "PNP0003"      /* APIC                                  */
+#define PNPExtInt     "IBM000D"      /* PowerPC Extended Interrupt Controller */
+
+/* Timers */
+
+#define PNPtimer0     "PNP0100"      /* AT Timer                              */
+#define PNPtimer1     "PNP0101"      /* EISA Timer                            */
+#define PNPtimer2     "PNP0102"      /* MCA Timer                             */
+
+/* DMA controllers */
+
+#define PNPdma0       "PNP0200"      /* AT DMA Controller                     */
+#define PNPdma1       "PNP0201"      /* EISA DMA Controller                   */
+#define PNPdma2       "PNP0202"      /* MCA DMA Controller                    */
+
+/* start of August 15, 1994 additions */
+/* CMOS */
+#define PNPCMOS       "IBM0009"      /* CMOS                                  */
+
+/* L2 Cache */
+#define PNPL2         "IBM0007"      /* L2 Cache                              */
+
+/* NVRAM */
+#define PNPNVRAM      "IBM0008"      /* NVRAM                                 */
+
+/* Power Management */
+#define PNPPM         "IBM0005"      /* Power Management                      */
+/* end of August 15, 1994 additions */
+
+/* Keyboards */
+
+#define PNPkeyboard0  "PNP0300"      /* IBM PC/XT KB Cntlr (83 key, no mouse) */
+#define PNPkeyboard1  "PNP0301"      /* Olivetti ICO (102 key)                */
+#define PNPkeyboard2  "PNP0302"      /* IBM PC/AT KB Cntlr (84 key)           */
+#define PNPkeyboard3  "PNP0303"      /* IBM Enhanced (101/2 key, PS/2 mouse)  */
+#define PNPkeyboard4  "PNP0304"      /* Nokia 1050 KB Cntlr                   */
+#define PNPkeyboard5  "PNP0305"      /* Nokia 9140 KB Cntlr                   */
+#define PNPkeyboard6  "PNP0306"      /* Standard Japanese KB Cntlr            */
+#define PNPkeyboard7  "PNP0307"      /* Microsoft Windows (R) KB Cntlr        */
+
+/* Parallel port controllers */
+
+#define PNPparallel0 "PNP0400"       /* Standard LPT Parallel Port            */
+#define PNPparallel1 "PNP0401"       /* ECP Parallel Port                     */
+#define PNPepp       "IBM001C"       /* EPP Parallel Port                     */
+
+/* Serial port controllers */
+
+#define PNPserial0   "PNP0500"       /* Standard PC Serial port               */
+#define PNPSerial1   "PNP0501"       /* 16550A Compatible Serial port         */
+
+/* Disk controllers */
+
+#define PNPdisk0     "PNP0600"       /* Generic ESDI/IDE/ATA Compat HD Cntlr  */
+#define PNPdisk1     "PNP0601"       /* Plus Hardcard II                      */
+#define PNPdisk2     "PNP0602"       /* Plus Hardcard IIXL/EZ                 */
+
+/* Diskette controllers */
+
+#define PNPdiskette0 "PNP0700"       /* PC Standard Floppy Disk Controller    */
+
+/* Display controllers */
+
+#define PNPdisplay0  "PNP0900"       /* VGA Compatible                        */
+#define PNPdisplay1  "PNP0901"       /* Video Seven VGA                       */
+#define PNPdisplay2  "PNP0902"       /* 8514/A Compatible                     */
+#define PNPdisplay3  "PNP0903"       /* Trident VGA                           */
+#define PNPdisplay4  "PNP0904"       /* Cirrus Logic Laptop VGA               */
+#define PNPdisplay5  "PNP0905"       /* Cirrus Logic VGA                      */
+#define PNPdisplay6  "PNP0906"       /* Tseng ET4000 or ET4000/W32            */
+#define PNPdisplay7  "PNP0907"       /* Western Digital VGA                   */
+#define PNPdisplay8  "PNP0908"       /* Western Digital Laptop VGA            */
+#define PNPdisplay9  "PNP0909"       /* S3                                    */
+#define PNPdisplayA  "PNP090A"       /* ATI Ultra Pro/Plus (Mach 32)          */
+#define PNPdisplayB  "PNP090B"       /* ATI Ultra (Mach 8)                    */
+#define PNPdisplayC  "PNP090C"       /* XGA Compatible                        */
+#define PNPdisplayD  "PNP090D"       /* ATI VGA Wonder                        */
+#define PNPdisplayE  "PNP090E"       /* Weitek P9000 Graphics Adapter         */
+#define PNPdisplayF  "PNP090F"       /* Oak Technology VGA                    */
+
+/* Peripheral busses */
+
+#define PNPbuses0    "PNP0A00"       /* ISA Bus                               */
+#define PNPbuses1    "PNP0A01"       /* EISA Bus                              */
+#define PNPbuses2    "PNP0A02"       /* MCA Bus                               */
+#define PNPbuses3    "PNP0A03"       /* PCI Bus                               */
+#define PNPbuses4    "PNP0A04"       /* VESA/VL Bus                           */
+
+/* RTC, BIOS, planar devices */
+
+#define PNPspeaker0  "PNP0800"       /* AT Style Speaker Sound                */
+#define PNPrtc0      "PNP0B00"       /* AT RTC                                */
+#define PNPpnpbios0  "PNP0C00"       /* PNP BIOS (only created by root enum)  */
+#define PNPpnpbios1  "PNP0C01"       /* System Board Memory Device            */
+#define PNPpnpbios2  "PNP0C02"       /* Math Coprocessor                      */
+#define PNPpnpbios3  "PNP0C03"       /* PNP BIOS Event Notification Interrupt */
+
+/* PCMCIA controller */
+
+#define PNPpcmcia0   "PNP0E00"       /* Intel 82365 Compatible PCMCIA Cntlr   */
+
+/* Mice */
+
+#define PNPmouse0    "PNP0F00"       /* Microsoft Bus Mouse                   */
+#define PNPmouse1    "PNP0F01"       /* Microsoft Serial Mouse                */
+#define PNPmouse2    "PNP0F02"       /* Microsoft Inport Mouse                */
+#define PNPmouse3    "PNP0F03"       /* Microsoft PS/2 Mouse                  */
+#define PNPmouse4    "PNP0F04"       /* Mousesystems Mouse                    */
+#define PNPmouse5    "PNP0F05"       /* Mousesystems 3 Button Mouse - COM2    */
+#define PNPmouse6    "PNP0F06"       /* Genius Mouse - COM1                   */
+#define PNPmouse7    "PNP0F07"       /* Genius Mouse - COM2                   */
+#define PNPmouse8    "PNP0F08"       /* Logitech Serial Mouse                 */
+#define PNPmouse9    "PNP0F09"       /* Microsoft Ballpoint Serial Mouse      */
+#define PNPmouseA    "PNP0F0A"       /* Microsoft PNP Mouse                   */
+#define PNPmouseB    "PNP0F0B"       /* Microsoft PNP Ballpoint Mouse         */
+
+/* Modems */
+
+#define PNPmodem0    "PNP9000"       /* Specific IDs TBD                      */
+
+/* Network controllers */
+
+#define PNPnetworkC9 "PNP80C9"       /* IBM Token Ring                        */
+#define PNPnetworkCA "PNP80CA"       /* IBM Token Ring II                     */
+#define PNPnetworkCB "PNP80CB"       /* IBM Token Ring II/Short               */
+#define PNPnetworkCC "PNP80CC"       /* IBM Token Ring 4/16Mbs                */
+#define PNPnetwork27 "PNP8327"       /* IBM Token Ring (All types)            */
+#define PNPnetworket "IBM0010"       /* IBM Ethernet used by Power PC         */
+#define PNPneteisaet "IBM2001"       /* IBM Ethernet EISA adapter             */
+#define PNPAMD79C970 "IBM0016"       /* AMD 79C970 (PCI Ethernet)             */
+
+/* SCSI controllers */
+
+#define PNPscsi0     "PNPA000"       /* Adaptec 154x Compatible SCSI Cntlr    */
+#define PNPscsi1     "PNPA001"       /* Adaptec 174x Compatible SCSI Cntlr    */
+#define PNPscsi2     "PNPA002"       /* Future Domain 16-700 Compat SCSI Cntlr*/
+#define PNPscsi3     "PNPA003"       /* Panasonic CDROM Adapter (SBPro/SB16)  */
+#define PNPscsiF     "IBM000F"       /* NCR 810 SCSI Controller               */
+#define PNPscsi825   "IBM001B"       /* NCR 825 SCSI Controller               */
+#define PNPscsi875   "IBM0018"       /* NCR 875 SCSI Controller               */
+
+/* Sound/Video, Multimedia */
+
+#define PNPmm0       "PNPB000"       /* Sound Blaster Compatible Sound Device */
+#define PNPmm1       "PNPB001"       /* MS Windows Sound System Compat Device */
+#define PNPmmF       "IBM000E"       /* Crystal CS4231 Audio Device           */
+#define PNPv7310     "IBM0015"       /* ASCII V7310 Video Capture Device      */
+#define PNPmm4232    "IBM0017"       /* Crystal CS4232 Audio Device           */
+#define PNPpmsyn     "IBM001D"       /* YMF 289B chip (Yamaha)                */
+#define PNPgp4232    "IBM0012"       /* Crystal CS4232 Game Port              */
+#define PNPmidi4232  "IBM0013"       /* Crystal CS4232 MIDI                   */
+
+/* Operator Panel */
+#define PNPopctl     "IBM000B"       /* Operator's panel                      */
+
+/* Service Processor */
+#define PNPsp        "IBM0011"       /* IBM Service Processor                 */
+#define PNPLTsp      "IBM001E"       /* Lightning/Terlingua Support Processor */
+#define PNPLTmsp     "IBM001F"       /* Lightning/Terlingua Mini-SP           */
+
+/* Memory Controller */
+#define PNPmemctl    "IBM000A"       /* Memory controller                     */
+
+/* Graphics Assist */
+#define PNPg_assist  "IBM0014"       /* Graphics Assist                       */
+
+/* Miscellaneous Device Controllers */
+#define PNPtablet    "IBM0019"       /* IBM Tablet Controller                 */
+
+/* PNP Packet Handles */
+
+#define S1_Packet                0x0A   /* Version resource                   */
+#define S2_Packet                0x15   /* Logical DEVID (without flags)      */
+#define S2_Packet_flags          0x16   /* Logical DEVID (with flags)         */
+#define S3_Packet                0x1C   /* Compatible device ID               */
+#define S4_Packet                0x22   /* IRQ resource (without flags)       */
+#define S4_Packet_flags          0x23   /* IRQ resource (with flags)          */
+#define S5_Packet                0x2A   /* DMA resource                       */
+#define S6_Packet                0x30   /* Depend funct start (w/o priority)  */
+#define S6_Packet_priority       0x31   /* Depend funct start (w/ priority)   */
+#define S7_Packet                0x38   /* Depend funct end                   */
+#define S8_Packet                0x47   /* I/O port resource (w/o fixed loc)  */
+#define S9_Packet_fixed          0x4B   /* I/O port resource (w/ fixed loc)   */
+#define S14_Packet               0x71   /* Vendor defined                     */
+#define S15_Packet               0x78   /* End of resource (w/o checksum)     */
+#define S15_Packet_checksum      0x79   /* End of resource (w/ checksum)      */
+#define L1_Packet                0x81   /* Memory range                       */
+#define L1_Shadow                0x20   /* Memory is shadowable               */
+#define L1_32bit_mem             0x18   /* 32-bit memory only                 */
+#define L1_8_16bit_mem           0x10   /* 8- and 16-bit supported            */
+#define L1_Decode_Hi             0x04   /* decode supports high address       */
+#define L1_Cache                 0x02   /* read cacheable, write-through      */
+#define L1_Writeable             0x01   /* Memory is writeable                */
+#define L2_Packet                0x82   /* ANSI ID string                     */
+#define L3_Packet                0x83   /* Unicode ID string                  */
+#define L4_Packet                0x84   /* Vendor defined                     */
+#define L5_Packet                0x85   /* Large I/O                          */
+#define L6_Packet                0x86   /* 32-bit Fixed Loc Mem Range Desc    */
+#define END_TAG                  0x78   /* End of resource                    */
+#define DF_START_TAG             0x30   /* Dependent function start           */
+#define DF_START_TAG_priority    0x31   /* Dependent function start           */
+#define DF_END_TAG               0x38   /* Dependent function end             */
+#define SUBOPTIMAL_CONFIGURATION 0x2    /* Priority byte sub optimal config   */
+
+/* Device Base Type Codes */
+
+typedef enum _PnP_BASE_TYPE {
+  Reserved = 0,
+  MassStorageDevice = 1,
+  NetworkInterfaceController = 2,
+  DisplayController = 3,
+  MultimediaController = 4,
+  MemoryController = 5,
+  BridgeController = 6,
+  CommunicationsDevice = 7,
+  SystemPeripheral = 8,
+  InputDevice = 9,
+  ServiceProcessor = 0x0A,              /* 11/2/95                            */
+  } PnP_BASE_TYPE;
+
+/* Device Sub Type Codes */
+
+typedef enum _PnP_SUB_TYPE {
+  SCSIController = 0,
+  IDEController = 1,
+  FloppyController = 2,
+  IPIController = 3,
+  OtherMassStorageController = 0x80,
+
+  EthernetController = 0,
+  TokenRingController = 1,
+  FDDIController = 2,
+  OtherNetworkController = 0x80,
+
+  VGAController= 0,
+  SVGAController= 1,
+  XGAController= 2,
+  OtherDisplayController = 0x80,
+
+  VideoController = 0,
+  AudioController = 1,
+  OtherMultimediaController = 0x80,
+
+  RAM = 0,
+  FLASH = 1,
+  OtherMemoryDevice = 0x80,
+
+  HostProcessorBridge = 0,
+  ISABridge = 1,
+  EISABridge = 2,
+  MicroChannelBridge = 3,
+  PCIBridge = 4,
+  PCMCIABridge = 5,
+  VMEBridge = 6,
+  OtherBridgeDevice = 0x80,
+
+  RS232Device = 0,
+  ATCompatibleParallelPort = 1,
+  OtherCommunicationsDevice = 0x80,
+
+  ProgrammableInterruptController = 0,
+  DMAController = 1,
+  SystemTimer = 2,
+  RealTimeClock = 3,
+  L2Cache = 4,
+  NVRAM = 5,
+  PowerManagement = 6,
+  CMOS = 7,
+  OperatorPanel = 8,
+  ServiceProcessorClass1 = 9,
+  ServiceProcessorClass2 = 0xA,
+  ServiceProcessorClass3 = 0xB,
+  GraphicAssist = 0xC,
+  SystemPlanar = 0xF,                   /* 10/5/95                            */
+  OtherSystemPeripheral = 0x80,
+
+  KeyboardController = 0,
+  Digitizer = 1,
+  MouseController = 2,
+  TabletController = 3,                 /* 10/27/95                           */
+  OtherInputController = 0x80,
+
+  GeneralMemoryController = 0,
+  } PnP_SUB_TYPE;
+
+/* Device Interface Type Codes */
+
+typedef enum _PnP_INTERFACE {
+  General = 0,
+  GeneralSCSI = 0,
+  GeneralIDE = 0,
+  ATACompatible = 1,
+
+  GeneralFloppy = 0,
+  Compatible765 = 1,
+  NS398_Floppy = 2,                     /* NS Super I/O wired to use index
+                                           register at port 398 and data
+                                           register at port 399               */
+  NS26E_Floppy = 3,                     /* Ports 26E and 26F                  */
+  NS15C_Floppy = 4,                     /* Ports 15C and 15D                  */
+  NS2E_Floppy = 5,                      /* Ports 2E and 2F                    */
+  CHRP_Floppy = 6,                      /* CHRP Floppy in PR*P system         */
+
+  GeneralIPI = 0,
+
+  GeneralEther = 0,
+  GeneralToken = 0,
+  GeneralFDDI = 0,
+
+  GeneralVGA = 0,
+  GeneralSVGA = 0,
+  GeneralXGA = 0,
+
+  GeneralVideo = 0,
+  GeneralAudio = 0,
+  CS4232Audio = 1,                      /* CS 4232 Plug 'n Play Configured    */
+
+  GeneralRAM = 0,
+  GeneralFLASH = 0,
+  PCIMemoryController = 0,              /* PCI Config Method                  */
+  RS6KMemoryController = 1,             /* RS6K Config Method                 */
+
+  GeneralHostBridge = 0,
+  GeneralISABridge = 0,
+  GeneralEISABridge = 0,
+  GeneralMCABridge = 0,
+  GeneralPCIBridge = 0,
+  PCIBridgeDirect = 0,
+  PCIBridgeIndirect = 1,
+  PCIBridgeRS6K = 2,
+  GeneralPCMCIABridge = 0,
+  GeneralVMEBridge = 0,
+
+  GeneralRS232 = 0,
+  COMx = 1,
+  Compatible16450 = 2,
+  Compatible16550 = 3,
+  NS398SerPort = 4,                     /* NS Super I/O wired to use index
+                                           register at port 398 and data
+                                           register at port 399               */
+  NS26ESerPort = 5,                     /* Ports 26E and 26F                  */
+  NS15CSerPort = 6,                     /* Ports 15C and 15D                  */
+  NS2ESerPort = 7,                      /* Ports 2E and 2F                    */
+
+  GeneralParPort = 0,
+  LPTx = 1,
+  NS398ParPort = 2,                     /* NS Super I/O wired to use index
+                                           register at port 398 and data
+                                           register at port 399               */
+  NS26EParPort = 3,                     /* Ports 26E and 26F                  */
+  NS15CParPort = 4,                     /* Ports 15C and 15D                  */
+  NS2EParPort = 5,                      /* Ports 2E and 2F                    */
+
+  GeneralPIC = 0,
+  ISA_PIC = 1,
+  EISA_PIC = 2,
+  MPIC = 3,
+  RS6K_PIC = 4,
+
+  GeneralDMA = 0,
+  ISA_DMA = 1,
+  EISA_DMA = 2,
+
+  GeneralTimer = 0,
+  ISA_Timer = 1,
+  EISA_Timer = 2,
+  GeneralRTC = 0,
+  ISA_RTC = 1,
+
+  StoreThruOnly = 1,
+  StoreInEnabled = 2,
+  RS6KL2Cache = 3,
+
+  IndirectNVRAM = 0,                    /* Indirectly addressed               */
+  DirectNVRAM = 1,                      /* Memory Mapped                      */
+  IndirectNVRAM24 = 2,                  /* Indirectly addressed - 24 bit      */
+
+  GeneralPowerManagement = 0,
+  EPOWPowerManagement = 1,
+  PowerControl = 2,                    // d1378
+
+  GeneralCMOS = 0,
+
+  GeneralOPPanel = 0,
+  HarddiskLight = 1,
+  CDROMLight = 2,
+  PowerLight = 3,
+  KeyLock = 4,
+  ANDisplay = 5,                        /* AlphaNumeric Display               */
+  SystemStatusLED = 6,                  /* 3 digit 7 segment LED              */
+  CHRP_SystemStatusLED = 7,             /* CHRP LEDs in PR*P system           */
+
+  GeneralServiceProcessor = 0,
+
+  TransferData = 1,
+  IGMC32 = 2,
+  IGMC64 = 3,
+
+  GeneralSystemPlanar = 0,              /* 10/5/95                            */
+
+  } PnP_INTERFACE;
+
+/* PnP resources */
+
+/* Compressed ASCII is 5 bits per char; 00001=A ... 11010=Z */
+
+typedef struct _SERIAL_ID {
+  unsigned char VendorID0;              /*    Bit(7)=0                        */
+                                        /*    Bits(6:2)=1st character in      */
+                                        /*       compressed ASCII             */
+                                        /*    Bits(1:0)=2nd character in      */
+                                        /*       compressed ASCII bits(4:3)   */
+  unsigned char VendorID1;              /*    Bits(7:5)=2nd character in      */
+                                        /*       compressed ASCII bits(2:0)   */
+                                        /*    Bits(4:0)=3rd character in      */
+                                        /*       compressed ASCII             */
+  unsigned char VendorID2;              /* Product number - vendor assigned   */
+  unsigned char VendorID3;              /* Product number - vendor assigned   */
+
+/* Serial number is to provide uniqueness if more than one board of same      */
+/* type is in system.  Must be "FFFFFFFF" if feature not supported.           */
+
+  unsigned char Serial0;                /* Unique serial number bits (7:0)    */
+  unsigned char Serial1;                /* Unique serial number bits (15:8)   */
+  unsigned char Serial2;                /* Unique serial number bits (23:16)  */
+  unsigned char Serial3;                /* Unique serial number bits (31:24)  */
+  unsigned char Checksum;
+  } SERIAL_ID;
+
+typedef enum _PnPItemName {
+  Unused = 0,
+  PnPVersion = 1,
+  LogicalDevice = 2,
+  CompatibleDevice = 3,
+  IRQFormat = 4,
+  DMAFormat = 5,
+  StartDepFunc = 6,
+  EndDepFunc = 7,
+  IOPort = 8,
+  FixedIOPort = 9,
+  Res1 = 10,
+  Res2 = 11,
+  Res3 = 12,
+  SmallVendorItem = 14,
+  EndTag = 15,
+  MemoryRange = 1,
+  ANSIIdentifier = 2,
+  UnicodeIdentifier = 3,
+  LargeVendorItem = 4,
+  MemoryRange32 = 5,
+  MemoryRangeFixed32 = 6,
+  } PnPItemName;
+
+/* Define a bunch of access functions for the bits in the tag field */
+
+/* Tag type - 0 = small; 1 = large */
+#define tag_type(t) (((t) & 0x80)>>7)
+#define set_tag_type(t,v) (t = (t & 0x7f) | ((v)<<7))
+
+/* Small item name is 4 bits - one of PnPItemName enum above */
+#define tag_small_item_name(t) (((t) & 0x78)>>3)
+#define set_tag_small_item_name(t,v) (t = (t & 0x07) | ((v)<<3))
+
+/* Small item count is 3 bits - count of further bytes in packet */
+#define tag_small_count(t) ((t) & 0x07)
+#define set_tag_count(t,v) (t = (t & 0x78) | (v))
+
+/* Large item name is 7 bits - one of PnPItemName enum above */
+#define tag_large_item_name(t) ((t) & 0x7f)
+#define set_tag_large_item_name(t,v) (t = (t | 0x80) | (v))
+
+/* a PnP resource is a bunch of contiguous TAG packets ending with an end tag */
+
+typedef union _PnP_TAG_PACKET {
+  struct _S1_Pack{                      /* VERSION PACKET                     */
+    unsigned char Tag;                  /* small tag = 0x0a                   */
+    unsigned char Version[2];           /* PnP version, Vendor version        */
+    } S1_Pack;
+
+  struct _S2_Pack{                      /* LOGICAL DEVICE ID PACKET           */
+    unsigned char Tag;                  /* small tag = 0x15 or 0x16           */
+    unsigned char DevId[4];             /* Logical device id                  */
+    unsigned char Flags[2];             /* bit(0) boot device;                */
+                                        /* bit(7:1) cmd in range x31-x37      */
+                                        /* bit(7:0) cmd in range x28-x3f (opt)*/
+    } S2_Pack;
+
+  struct _S3_Pack{                      /* COMPATIBLE DEVICE ID PACKET        */
+    unsigned char Tag;                  /* small tag = 0x1c                   */
+    unsigned char CompatId[4];          /* Compatible device id               */
+    } S3_Pack;
+
+  struct _S4_Pack{                      /* IRQ PACKET                         */
+    unsigned char Tag;                  /* small tag = 0x22 or 0x23           */
+    unsigned char IRQMask[2];           /* bit(0) is IRQ0, ...;               */
+                                        /* bit(0) is IRQ8 ...                 */
+    unsigned char IRQInfo;              /* optional; assume bit(0)=1; else    */
+                                        /*  bit(0) - high true edge sensitive */
+                                        /*  bit(1) - low true edge sensitive  */
+                                        /*  bit(2) - high true level sensitive*/
+                                        /*  bit(3) - low true level sensitive */
+                                        /*  bit(7:4) - must be 0              */
+    } S4_Pack;
+
+  struct _S5_Pack{                      /* DMA PACKET                         */
+    unsigned char Tag;                  /* small tag = 0x2a                   */
+    unsigned char DMAMask;              /* bit(0) is channel 0 ...            */
+    unsigned char DMAInfo;
+    } S5_Pack;
+
+  struct _S6_Pack{                      /* START DEPENDENT FUNCTION PACKET    */
+    unsigned char Tag;                  /* small tag = 0x30 or 0x31           */
+    unsigned char Priority;             /* Optional; if missing then x01; else*/
+                                        /*  x00 = best possible               */
+                                        /*  x01 = acceptible                  */
+                                        /*  x02 = sub-optimal but functional  */
+    } S6_Pack;
+
+  struct _S7_Pack{                      /* END DEPENDENT FUNCTION PACKET      */
+    unsigned char Tag;                  /* small tag = 0x38                   */
+    } S7_Pack;
+
+  struct _S8_Pack{                      /* VARIABLE I/O PORT PACKET           */
+    unsigned char Tag;                  /* small tag x47                      */
+    unsigned char IOInfo;               /* x0  = decode only bits(9:0);       */
+#define  ISAAddr16bit         0x01      /* x01 = decode bits(15:0)            */
+    unsigned char RangeMin[2];          /* Min base address                   */
+    unsigned char RangeMax[2];          /* Max base address                   */
+    unsigned char IOAlign;              /* base alignmt, incr in 1B blocks    */
+    unsigned char IONum;                /* number of contiguous I/O ports     */
+    } S8_Pack;
+
+  struct _S9_Pack{                      /* FIXED I/O PORT PACKET              */
+    unsigned char Tag;                  /* small tag = 0x4b                   */
+    unsigned char Range[2];             /* base address 10 bits               */
+    unsigned char IONum;                /* number of contiguous I/O ports     */
+    } S9_Pack;
+
+  struct _S14_Pack{                     /* VENDOR DEFINED PACKET              */
+    unsigned char Tag;                  /* small tag = 0x7m m = 1-7           */
+    union _S14_Data{
+      unsigned char Data[7];            /* Vendor defined                     */
+      struct _S14_PPCPack{              /* Pr*p s14 pack                      */
+         unsigned char Type;            /* 00=non-IBM                         */
+         unsigned char PPCData[6];      /* Vendor defined                     */
+        } S14_PPCPack;
+      } S14_Data;
+    } S14_Pack;
+
+  struct _S15_Pack{                     /* END PACKET                         */
+    unsigned char Tag;                  /* small tag = 0x78 or 0x79           */
+    unsigned char Check;                /* optional - checksum                */
+    } S15_Pack;
+
+  struct _L1_Pack{                      /* MEMORY RANGE PACKET                */
+    unsigned char Tag;                  /* large tag = 0x81                   */
+    unsigned char Count0;               /* x09                                */
+    unsigned char Count1;               /* x00                                */
+    unsigned char Data[9];              /* a variable array of bytes,         */
+                                        /* count in tag                       */
+    } L1_Pack;
+
+  struct _L2_Pack{                      /* ANSI ID STRING PACKET              */
+    unsigned char Tag;                  /* large tag = 0x82                   */
+    unsigned char Count0;               /* Length of string                   */
+    unsigned char Count1;
+    unsigned char Identifier[1];        /* a variable array of bytes,         */
+                                        /* count in tag                       */
+    } L2_Pack;
+
+  struct _L3_Pack{                      /* UNICODE ID STRING PACKET           */
+    unsigned char Tag;                  /* large tag = 0x83                   */
+    unsigned char Count0;               /* Length + 2 of string               */
+    unsigned char Count1;
+    unsigned char Country0;             /* TBD                                */
+    unsigned char Country1;             /* TBD                                */
+    unsigned char Identifier[1];        /* a variable array of bytes,         */
+                                        /* count in tag                       */
+    } L3_Pack;
+
+  struct _L4_Pack{                      /* VENDOR DEFINED PACKET              */
+    unsigned char Tag;                  /* large tag = 0x84                   */
+    unsigned char Count0;
+    unsigned char Count1;
+    union _L4_Data{
+      unsigned char Data[1];            /* a variable array of bytes,         */
+                                        /* count in tag                       */
+      struct _L4_PPCPack{               /* Pr*p L4 packet                     */
+         unsigned char Type;            /* 00=non-IBM                         */
+         unsigned char PPCData[1];      /* a variable array of bytes,         */
+                                        /* count in tag                       */
+        } L4_PPCPack;
+      } L4_Data;
+    } L4_Pack;
+
+  struct _L5_Pack{
+    unsigned char Tag;                  /* large tag = 0x85                   */
+    unsigned char Count0;               /* Count = 17                         */
+    unsigned char Count1;
+    unsigned char Data[17];
+    } L5_Pack;
+
+  struct _L6_Pack{
+    unsigned char Tag;                  /* large tag = 0x86                   */
+    unsigned char Count0;               /* Count = 9                          */
+    unsigned char Count1;
+    unsigned char Data[9];
+    } L6_Pack;
+
+  } PnP_TAG_PACKET;
+
+#endif				/* _PPC_BOOT_PNP_H_ */
Index: working-2.6/arch/powerpc/boot/residual.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/boot/residual.h	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,313 @@
+/* 7/18/95                                                                    */
+/*----------------------------------------------------------------------------*/
+/*      Residual Data header definitions and prototypes                       */
+/*----------------------------------------------------------------------------*/
+
+/* Structure map for RESIDUAL on PowerPC Reference Platform                   */
+/* residual.h - Residual data structure passed in r3.                         */
+/*              Load point passed in r4 to boot image.                        */
+/* For enum's: if given in hex then they are bit significant,                 */
+/*             i.e. only one bit is on for each enum                          */
+/* Reserved fields must be filled with zeros.                                */
+#ifndef _PPC_BOOT_RESIDUAL_H_
+#define _PPC_BOOT_RESIDUAL_H_
+
+#define MAX_CPUS 32                     /* These should be set to the maximum */
+#define MAX_MEMS 64                     /* number possible for this system.   */
+#define MAX_DEVICES 256                 /* Changing these will change the     */
+#define AVE_PNP_SIZE 32                 /* structure, hence the version of    */
+#define MAX_MEM_SEGS 64                 /* this header file.                  */
+
+/*----------------------------------------------------------------------------*/
+/*               Public structures...                                         */
+/*----------------------------------------------------------------------------*/
+
+#include "pnp.h"
+
+typedef enum _L1CACHE_TYPE {
+  NoneCAC = 0,
+  SplitCAC = 1,
+  CombinedCAC = 2
+  } L1CACHE_TYPE;
+
+typedef enum _TLB_TYPE {
+  NoneTLB = 0,
+  SplitTLB = 1,
+  CombinedTLB = 2
+  } TLB_TYPE;
+
+typedef enum _FIRMWARE_SUPPORT {
+  Conventional = 0x01,
+  OpenFirmware = 0x02,
+  Diagnostics = 0x04,
+  LowDebug = 0x08,
+  Multiboot = 0x10,
+  LowClient = 0x20,
+  Hex41 = 0x40,
+  FAT = 0x80,
+  ISO9660 = 0x0100,
+  SCSI_InitiatorID_Override = 0x0200,
+  Tape_Boot = 0x0400,
+  FW_Boot_Path = 0x0800
+  } FIRMWARE_SUPPORT;
+
+typedef enum _FIRMWARE_SUPPLIERS {
+  IBMFirmware = 0x00,
+  MotoFirmware = 0x01,                  /* 7/18/95                            */
+  FirmWorks = 0x02,                     /* 10/5/95                            */
+  Bull = 0x03,                          /* 04/03/96                           */
+  } FIRMWARE_SUPPLIERS;
+
+typedef enum _ENDIAN_SWITCH_METHODS {
+  UsePort92 = 0x01,
+  UsePCIConfigA8 = 0x02,
+  UseFF001030 = 0x03,
+  } ENDIAN_SWITCH_METHODS;
+
+typedef enum _SPREAD_IO_METHODS {
+  UsePort850 = 0x00,
+/*UsePCIConfigA8 = 0x02,*/
+  } SPREAD_IO_METHODS;
+
+typedef struct _VPD {
+
+  /* Box dependent stuff */
+  unsigned char PrintableModel[32];     /* Null terminated string.
+                                           Must be of the form:
+                                           vvv,<20h>,<model designation>,<0x0>
+                                           where vvv is the vendor ID
+                                           e.g. IBM PPS MODEL 6015<0x0>       */
+  unsigned char Serial[16];             /* 12/94:
+                                           Serial Number; must be of the form:
+                                           vvv<serial number> where vvv is the
+                                           vendor ID.
+                                           e.g. IBM60151234567<20h><20h>      */
+  unsigned char Reserved[48];
+  unsigned long FirmwareSupplier;       /* See FirmwareSuppliers enum         */
+  unsigned long FirmwareSupports;       /* See FirmwareSupport enum           */
+  unsigned long NvramSize;              /* Size of nvram in bytes             */
+  unsigned long NumSIMMSlots;
+  unsigned short EndianSwitchMethod;    /* See EndianSwitchMethods enum       */
+  unsigned short SpreadIOMethod;        /* See SpreadIOMethods enum           */
+  unsigned long SmpIar;
+  unsigned long RAMErrLogOffset;        /* Heap offset to error log           */
+  unsigned long Reserved5;
+  unsigned long Reserved6;
+  unsigned long ProcessorHz;            /* Processor clock frequency in Hertz */
+  unsigned long ProcessorBusHz;         /* Processor bus clock frequency      */
+  unsigned long Reserved7;
+  unsigned long TimeBaseDivisor;        /* (Bus clocks per timebase tic)*1000 */
+  unsigned long WordWidth;              /* Word width in bits                 */
+  unsigned long PageSize;               /* Page size in bytes                 */
+  unsigned long CoherenceBlockSize;     /* Unit of transfer in/out of cache
+                                           for which coherency is maintained;
+                                           normally <= CacheLineSize.         */
+  unsigned long GranuleSize;            /* Unit of lock allocation to avoid   */
+                                        /*   false sharing of locks.          */
+
+  /* L1 Cache variables */
+  unsigned long CacheSize;              /* L1 Cache size in KB. This is the   */
+                                        /*   total size of the L1, whether    */
+                                        /*   combined or split                */
+  unsigned long CacheAttrib;            /* L1CACHE_TYPE                       */
+  unsigned long CacheAssoc;             /* L1 Cache associativity. Use this
+                                           for combined cache. If split, put
+                                           zeros here.                        */
+  unsigned long CacheLineSize;          /* L1 Cache line size in bytes. Use
+                                           for combined cache. If split, put
+                                           zeros here.                        */
+  /* For split L1 Cache: (= combined if combined cache) */
+  unsigned long I_CacheSize;
+  unsigned long I_CacheAssoc;
+  unsigned long I_CacheLineSize;
+  unsigned long D_CacheSize;
+  unsigned long D_CacheAssoc;
+  unsigned long D_CacheLineSize;
+
+  /* Translation Lookaside Buffer variables */
+  unsigned long TLBSize;                /* Total number of TLBs on the system */
+  unsigned long TLBAttrib;              /* Combined I+D or split TLB          */
+  unsigned long TLBAssoc;               /* TLB Associativity. Use this for
+                                           combined TLB. If split, put zeros
+                                           here.                              */
+  /* For split TLB: (= combined if combined TLB) */
+  unsigned long I_TLBSize;
+  unsigned long I_TLBAssoc;
+  unsigned long D_TLBSize;
+  unsigned long D_TLBAssoc;
+
+  unsigned long ExtendedVPD;            /* Offset to extended VPD area;
+                                           null if unused                     */
+  } VPD;
+
+typedef enum _DEVICE_FLAGS {
+  Enabled = 0x4000,                     /* 1 - PCI device is enabled          */
+  Integrated = 0x2000,
+  Failed = 0x1000,                      /* 1 - device failed POST code tests  */
+  Static = 0x0800,                      /* 0 - dynamically configurable
+                                           1 - static                         */
+  Dock = 0x0400,                        /* 0 - not a docking station device
+                                           1 - is a docking station device    */
+  Boot = 0x0200,                        /* 0 - device cannot be used for BOOT
+                                           1 - can be a BOOT device           */
+  Configurable = 0x0100,                /* 1 - device is configurable         */
+  Disableable = 0x80,                   /* 1 - device can be disabled         */
+  PowerManaged = 0x40,                  /* 0 - not managed; 1 - managed       */
+  ReadOnly = 0x20,                      /* 1 - device is read only            */
+  Removable = 0x10,                     /* 1 - device is removable            */
+  ConsoleIn = 0x08,
+  ConsoleOut = 0x04,
+  Input = 0x02,
+  Output = 0x01
+  } DEVICE_FLAGS;
+
+typedef enum _BUS_ID {
+  ISADEVICE = 0x01,
+  EISADEVICE = 0x02,
+  PCIDEVICE = 0x04,
+  PCMCIADEVICE = 0x08,
+  PNPISADEVICE = 0x10,
+  MCADEVICE = 0x20,
+  MXDEVICE = 0x40,                      /* Devices on mezzanine bus           */
+  PROCESSORDEVICE = 0x80,               /* Devices on processor bus           */
+  VMEDEVICE = 0x100,
+  } BUS_ID;
+
+typedef struct _DEVICE_ID {
+  unsigned long BusId;                  /* See BUS_ID enum above              */
+  unsigned long DevId;                  /* Big Endian format                  */
+  unsigned long SerialNum;              /* For multiple usage of a single
+                                           DevId                              */
+  unsigned long Flags;                  /* See DEVICE_FLAGS enum above        */
+  unsigned char BaseType;               /* See pnp.h for bit definitions      */
+  unsigned char SubType;                /* See pnp.h for bit definitions      */
+  unsigned char Interface;              /* See pnp.h for bit definitions      */
+  unsigned char Spare;
+  } DEVICE_ID;
+
+typedef union _BUS_ACCESS {
+  struct _PnPAccess{
+    unsigned char CSN;
+    unsigned char LogicalDevNumber;
+    unsigned short ReadDataPort;
+    } PnPAccess;
+  struct _ISAAccess{
+    unsigned char SlotNumber;           /* ISA Slot Number generally not
+                                           available; 0 if unknown            */
+    unsigned char LogicalDevNumber;
+    unsigned short ISAReserved;
+    } ISAAccess;
+  struct _MCAAccess{
+    unsigned char SlotNumber;
+    unsigned char LogicalDevNumber;
+    unsigned short MCAReserved;
+    } MCAAccess;
+  struct _PCMCIAAccess{
+    unsigned char SlotNumber;
+    unsigned char LogicalDevNumber;
+    unsigned short PCMCIAReserved;
+    } PCMCIAAccess;
+  struct _EISAAccess{
+    unsigned char SlotNumber;
+    unsigned char FunctionNumber;
+    unsigned short EISAReserved;
+    } EISAAccess;
+  struct _PCIAccess{
+    unsigned char BusNumber;
+    unsigned char DevFuncNumber;
+    unsigned short PCIReserved;
+    } PCIAccess;
+  struct _ProcBusAccess{
+    unsigned char BusNumber;
+    unsigned char BUID;
+    unsigned short ProcBusReserved;
+    } ProcBusAccess;
+  } BUS_ACCESS;
+
+/* Per logical device information */
+typedef struct _PPC_DEVICE {
+  DEVICE_ID DeviceId;
+  BUS_ACCESS BusAccess;
+
+  /* The following three are offsets into the DevicePnPHeap */
+  /* All are in PnP compressed format                       */
+  unsigned long AllocatedOffset;        /* Allocated resource description     */
+  unsigned long PossibleOffset;         /* Possible resource description      */
+  unsigned long CompatibleOffset;       /* Compatible device identifiers      */
+  } PPC_DEVICE;
+
+typedef enum _CPU_STATE {
+  CPU_GOOD = 0,                         /* CPU is present, and active         */
+  CPU_GOOD_FW = 1,                      /* CPU is present, and in firmware    */
+  CPU_OFF = 2,                          /* CPU is present, but inactive       */
+  CPU_FAILED = 3,                       /* CPU is present, but failed POST    */
+  CPU_NOT_PRESENT = 255                 /* CPU not present                    */
+  } CPU_STATE;
+
+typedef struct _PPC_CPU {
+  unsigned long CpuType;                /* Result of mfspr from Processor
+                                           Version Register (PVR).
+                                           PVR(0-15) = Version (e.g. 601)
+                                           PVR(16-31 = EC Level               */
+  unsigned char CpuNumber;              /* CPU Number for this processor      */
+  unsigned char CpuState;               /* CPU State, see CPU_STATE enum      */
+  unsigned short Reserved;
+  } PPC_CPU;
+
+typedef struct _PPC_MEM {
+  unsigned long SIMMSize;               /* 0 - absent or bad
+                                           8M, 32M (in MB)                    */
+  } PPC_MEM;
+
+typedef enum _MEM_USAGE {
+  Other = 0x8000,
+  ResumeBlock = 0x4000,                 /* for use by power management        */
+  SystemROM = 0x2000,                   /* Flash memory (populated)           */
+  UnPopSystemROM = 0x1000,              /* Unpopulated part of SystemROM area */
+  IOMemory = 0x0800,
+  SystemIO = 0x0400,
+  SystemRegs = 0x0200,
+  PCIAddr = 0x0100,
+  PCIConfig = 0x80,
+  ISAAddr = 0x40,
+  Unpopulated = 0x20,                   /* Unpopulated part of System Memory  */
+  Free = 0x10,                          /* Free part of System Memory         */
+  BootImage = 0x08,                     /* BootImage part of System Memory    */
+  FirmwareCode = 0x04,                  /* FirmwareCode part of System Memory */
+  FirmwareHeap = 0x02,                  /* FirmwareHeap part of System Memory */
+  FirmwareStack = 0x01                  /* FirmwareStack part of System Memory*/
+  } MEM_USAGE;
+
+typedef struct _MEM_MAP {
+  unsigned long Usage;                  /* See MEM_USAGE above                */
+  unsigned long BasePage;               /* Page number measured in 4KB pages  */
+  unsigned long PageCount;              /* Page count measured in 4KB pages   */
+  } MEM_MAP;
+
+typedef struct _RESIDUAL {
+  unsigned long ResidualLength;         /* Length of Residual                 */
+  unsigned char Version;                /* of this data structure             */
+  unsigned char Revision;               /* of this data structure             */
+  unsigned short EC;                    /* of this data structure             */
+  /* VPD */
+  VPD VitalProductData;
+  /* CPU */
+  unsigned short MaxNumCpus;            /* Max CPUs in this system            */
+  unsigned short ActualNumCpus;         /* ActualNumCpus < MaxNumCpus means   */
+                                        /* that there are unpopulated or      */
+                                        /* otherwise unusable cpu locations   */
+  PPC_CPU Cpus[MAX_CPUS];
+  /* Memory */
+  unsigned long TotalMemory;            /* Total amount of memory installed   */
+  unsigned long GoodMemory;             /* Total amount of good memory        */
+  unsigned long ActualNumMemSegs;
+  MEM_MAP Segs[MAX_MEM_SEGS];
+  unsigned long ActualNumMemories;
+  PPC_MEM Memories[MAX_MEMS];
+  /* Devices */
+  unsigned long ActualNumDevices;
+  PPC_DEVICE Devices[MAX_DEVICES];
+  unsigned char DevicePnPHeap[2*MAX_DEVICES*AVE_PNP_SIZE];
+  } RESIDUAL;
+
+#endif				/* _PPC_BOOT_RESIDUAL_H_ */
Index: working-2.6/arch/powerpc/kernel/udbg.c
===================================================================
--- working-2.6.orig/arch/powerpc/kernel/udbg.c	2007-08-06 13:48:11.000000000 +1000
+++ working-2.6/arch/powerpc/kernel/udbg.c	2007-08-06 14:01:48.000000000 +1000
@@ -54,6 +54,8 @@ void __init udbg_early_init(void)
 #elif defined(CONFIG_PPC_EARLY_DEBUG_44x)
 	/* PPC44x debug */
 	udbg_init_44x_as1();
+#elif defined(CONFIG_PPC_EARLY_DEBUG_PREP)
+	udbg_init_prep();
 #endif
 }
 
Index: working-2.6/arch/powerpc/platforms/Makefile
===================================================================
--- working-2.6.orig/arch/powerpc/platforms/Makefile	2007-08-06 13:48:11.000000000 +1000
+++ working-2.6/arch/powerpc/platforms/Makefile	2007-08-06 14:01:48.000000000 +1000
@@ -6,6 +6,7 @@ obj-$(CONFIG_PPC_PMAC)		+= powermac/
 endif
 endif
 obj-$(CONFIG_PPC_CHRP)		+= chrp/
+obj-$(CONFIG_PPC_PREP)		+= prep/
 #obj-$(CONFIG_4xx)		+= 4xx/
 obj-$(CONFIG_44x)		+= 44x/
 obj-$(CONFIG_PPC_MPC52xx)	+= 52xx/
Index: working-2.6/include/asm-powerpc/udbg.h
===================================================================
--- working-2.6.orig/include/asm-powerpc/udbg.h	2007-08-06 13:48:11.000000000 +1000
+++ working-2.6/include/asm-powerpc/udbg.h	2007-08-06 14:01:48.000000000 +1000
@@ -48,6 +48,7 @@ extern void __init udbg_init_rtas_consol
 extern void __init udbg_init_debug_beat(void);
 extern void __init udbg_init_btext(void);
 extern void __init udbg_init_44x_as1(void);
+extern void __init udbg_init_prep(void);
 
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_UDBG_H */
Index: working-2.6/arch/powerpc/platforms/prep/Kconfig
===================================================================
--- working-2.6.orig/arch/powerpc/platforms/prep/Kconfig	2007-08-06 13:48:11.000000000 +1000
+++ working-2.6/arch/powerpc/platforms/prep/Kconfig	2007-08-06 14:01:48.000000000 +1000
@@ -1,11 +1,12 @@
 config PPC_PREP
 	bool "PowerPC Reference Platform (PReP) based machines"
-	depends on PPC_MULTIPLATFORM && PPC32 && BROKEN
+	depends on PPC_MULTIPLATFORM && PPC32
 	select MPIC
 	select PPC_I8259
 	select PPC_INDIRECT_PCI
 	select PPC_UDBG_16550
 	select PPC_NATIVE
+	select WANT_DEVICE_TREE
 	default n
 
 config PREP_RESIDUAL
Index: working-2.6/arch/powerpc/configs/prep_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ working-2.6/arch/powerpc/configs/prep_defconfig	2007-08-06 14:01:48.000000000 +1000
@@ -0,0 +1,1006 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22-rc4-prep-support
+# Wed Jun 27 16:38:31 2007
+#
+# CONFIG_PPC64 is not set
+
+#
+# Processor support
+#
+CONFIG_CLASSIC32=y
+# CONFIG_PPC_82xx is not set
+# CONFIG_PPC_83xx is not set
+# CONFIG_PPC_85xx is not set
+# CONFIG_PPC_86xx is not set
+# CONFIG_PPC_8xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_E200 is not set
+CONFIG_6xx=y
+CONFIG_PPC_FPU=y
+# CONFIG_ALTIVEC is not set
+CONFIG_PPC_STD_MMU=y
+CONFIG_PPC_STD_MMU_32=y
+# CONFIG_PPC_MM_SLICES is not set
+# CONFIG_SMP is not set
+CONFIG_PPC32=y
+CONFIG_PPC_MERGE=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_IRQ_PER_CPU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_ILOG2_U32=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_PPC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_PPC_OF=y
+CONFIG_PPC_UDBG_16550=y
+# CONFIG_GENERIC_TBSYNC is not set
+CONFIG_AUDIT_ARCH=y
+CONFIG_GENERIC_BUG=y
+# CONFIG_DEFAULT_UIMAGE is not set
+# CONFIG_PPC_DCR_NATIVE is not set
+# CONFIG_PPC_DCR_MMIO is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Platform support
+#
+CONFIG_PPC_MULTIPLATFORM=y
+# CONFIG_EMBEDDED6xx is not set
+# CONFIG_PPC_CHRP is not set
+# CONFIG_PPC_MPC52xx is not set
+# CONFIG_PPC_MPC5200 is not set
+# CONFIG_PPC_EFIKA is not set
+# CONFIG_PPC_LITE5200 is not set
+# CONFIG_PPC_PMAC is not set
+CONFIG_PPC_PREP=y
+CONFIG_PREP_RESIDUAL=y
+CONFIG_PROC_PREPRESIDUAL=y
+# CONFIG_PPC_CELL is not set
+# CONFIG_PPC_CELL_NATIVE is not set
+# CONFIG_PQ2ADS is not set
+CONFIG_PPC_NATIVE=y
+CONFIG_MPIC=y
+# CONFIG_MPIC_WEIRD is not set
+CONFIG_PPC_I8259=y
+# CONFIG_PPC_RTAS is not set
+# CONFIG_MMIO_NVRAM is not set
+# CONFIG_PPC_MPC106 is not set
+# CONFIG_PPC_970_NAP is not set
+# CONFIG_PPC_INDIRECT_IO is not set
+# CONFIG_GENERIC_IOMAP is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_PPC601_SYNC_FIX is not set
+# CONFIG_TAU is not set
+# CONFIG_CPM2 is not set
+
+#
+# Kernel options
+#
+# CONFIG_HIGHMEM is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+# CONFIG_KEXEC is not set
+CONFIG_PPCBUG_NVRAM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SECCOMP is not set
+CONFIG_WANT_DEVICE_TREE=y
+CONFIG_DEVICE_TREE="prep.dts"
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+# CONFIG_ISA is not set
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_PPC_INDIRECT_PCI=y
+# CONFIG_PPC_INDIRECT_PCI_BE is not set
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCIEPORTBUS is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+CONFIG_BLK_DEV_FD=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_BLINK is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+CONFIG_MACINTOSH_DRIVERS=y
+# CONFIG_MAC_EMUMOUSEBTN is not set
+# CONFIG_WINDFARM is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=y
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+CONFIG_TULIP_MMIO=y
+# CONFIG_TULIP_NAPI is not set
+CONFIG_DE4X5=y
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_ULI526X is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+CONFIG_PCNET32_NAPI=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_NVRAM=y
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+# CONFIG_HWMON is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_FB is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_VFAT_FS is not set
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf-8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+# CONFIG_UCC_SLOW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+
+#
+# Instrumentation Support
+#
+# CONFIG_PROFILING is not set
+# CONFIG_KPROBES is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_DEBUGGER=y
+CONFIG_XMON=y
+CONFIG_XMON_DEFAULT=y
+CONFIG_XMON_DISASSEMBLY=y
+# CONFIG_BDI_SWITCH is not set
+CONFIG_BOOTX_TEXT=y
+CONFIG_PPC_EARLY_DEBUG=y
+# CONFIG_PPC_EARLY_DEBUG_LPAR is not set
+# CONFIG_PPC_EARLY_DEBUG_G5 is not set
+# CONFIG_PPC_EARLY_DEBUG_RTAS_PANEL is not set
+# CONFIG_PPC_EARLY_DEBUG_RTAS_CONSOLE is not set
+# CONFIG_PPC_EARLY_DEBUG_MAPLE is not set
+# CONFIG_PPC_EARLY_DEBUG_ISERIES is not set
+# CONFIG_PPC_EARLY_DEBUG_PAS_REALMODE is not set
+# CONFIG_PPC_EARLY_DEBUG_BEAT is not set
+# CONFIG_PPC_EARLY_DEBUG_44x is not set
+CONFIG_PPC_EARLY_DEBUG_PREP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
--- linux-2.6.23-rc3/arch/powerpc/platforms/prep/setup.c	2007-08-22 02:21:52.000000000 -0500
+++ linux-2.6.23-new/arch/powerpc/platforms/prep/setup.c	2007-08-22 04:20:37.000000000 -0500
@@ -21,6 +21,7 @@
 #include <asm/i8259.h>
 #include <asm/time.h>
 #include <asm/udbg.h>
+#include <linux/ide.h>
 
 static const char *prep_model = "(unknown)";
 
@@ -436,7 +437,7 @@
 		return;
 	}
 
-	hose = pcibios_alloc_controller();
+	hose = pcibios_alloc_controller(phb);
 	if (!hose)
 		return;
 
@@ -448,7 +449,7 @@
 	DMA_MODE_WRITE = 0x48;
 
 	setup_indirect_pci(hose, hose->io_base_phys + 0xcf8,
-			   hose->io_base_phys + 0xcfc);
+			   hose->io_base_phys + 0xcfc, 0);
 }
 
 static void __init prep_setup_arch(void)
diff -ru a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile
--- a/arch/powerpc/boot/Makefile	2007-08-22 18:10:29.000000000 -0500
+++ b/arch/powerpc/boot/Makefile	2007-08-22 19:07:32.000000000 -0500
@@ -136,7 +136,7 @@
 image-$(CONFIG_PPC_HOLLY)		+= zImage.holly
 image-$(CONFIG_PPC_PRPMC2800)		+= zImage.prpmc2800
 image-$(CONFIG_PPC_ISERIES)		+= zImage.iseries
-image-$(CONFIG_PPC_PREP)		+= zImage.dts.prep
+image-$(CONFIG_PPC_PREP)		+= zImage.prep
 image-$(CONFIG_DEFAULT_UIMAGE)		+= uImage
 
 ifneq ($(CONFIG_DEVICE_TREE),"")
Only in linux-2.6.23-rc3/arch/powerpc/boot/: mkprep
Only in linux-2.6.23-rc3/arch/powerpc/boot/: mkprep2
diff -ru linux-2.6.23-rc3/arch/powerpc/boot/mkprep.c build/host-temp/linux-2.6.23-rc3/arch/powerpc/boot/mkprep.c
--- linux-2.6.23-rc3/arch/powerpc/boot/mkprep.c	2007-08-22 19:05:12.000000000 -0500
+++ build/host-temp/linux-2.6.23-rc3/arch/powerpc/boot/mkprep.c	2007-08-22 19:07:32.000000000 -0500
@@ -97,8 +97,8 @@
 	      be16_to_cpu(elf32->e_machine) == EM_PPC))
 		die("Input doesn't appear to be a PowerPC ELF image\n");
 
-	elf32ph = (Elf32_Phdr *) (elfheader + elf32->e_phoff);
-	for (i = 0; i < elf32->e_phnum; i++, elf32ph++)
+	elf32ph = (Elf32_Phdr *) (elfheader + be32_to_cpu(elf32->e_phoff));
+	for (i = 0; i < be16_to_cpu(elf32->e_phnum); i++, elf32ph++)
 		if (be32_to_cpu(elf32ph->p_type) == PT_LOAD)
 			break;
 	if (i >= be16_to_cpu(elf32->e_phnum))
